# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type ApplicationPresenter {
  _count: ApplicationPresenterCount
  bioEn: String!
  bioHr: String!
  createdAt: DateTime!
  firstName: String!
  lastName: String!
  updatedAt: DateTime!
}

type ApplicationPresenterCount {
  forTalks: Int!
  forWorkshops: Int!
}

type ApplicationTalk {
  _count: ApplicationTalkCount
  category: ApplicationTalkCategory!
  createdAt: DateTime!
  descriptionEn: String!
  descriptionHr: String!
  language: String!
  presenters: [ApplicationPresenter!]!
  titleEn: String!
  titleHr: String!
  uid: String!
  updatedAt: DateTime!
}

type ApplicationTalkCategory {
  _count: ApplicationTalkCategoryCount
  name: String!
}

type ApplicationTalkCategoryCount {
  talks: Int!
}

input ApplicationTalkCategoryOrderByWithRelationInput {
  name: SortOrder
}

input ApplicationTalkCategoryRelationFilter {
  is: ApplicationTalkCategoryWhereInput
  isNot: ApplicationTalkCategoryWhereInput
}

enum ApplicationTalkCategoryScalarFieldEnum {
  id
  name
}

input ApplicationTalkCategoryWhereInput {
  AND: [ApplicationTalkCategoryWhereInput!]
  NOT: [ApplicationTalkCategoryWhereInput!]
  OR: [ApplicationTalkCategoryWhereInput!]
  name: StringFilter
}

input ApplicationTalkCategoryWhereUniqueInput {
  name: String
}

type ApplicationTalkCount {
  presenters: Int!
}

input ApplicationTalkRelationFilter {
  is: ApplicationTalkWhereInput
  isNot: ApplicationTalkWhereInput
}

input ApplicationTalkWhereInput {
  AND: [ApplicationTalkWhereInput!]
  NOT: [ApplicationTalkWhereInput!]
  OR: [ApplicationTalkWhereInput!]
  category: ApplicationTalkCategoryRelationFilter
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  language: StringFilter
  titleEn: StringFilter
  titleHr: StringFilter
}

type ApplicationWorkshop {
  _count: ApplicationWorkshopCount
  createdAt: DateTime!
  descriptionEn: String!
  descriptionHr: String!
  goal: String!
  language: String!
  notesEn: String!
  notesHr: String!
  presenters: [ApplicationPresenter!]!
  titleEn: String!
  titleHr: String!
  uid: String!
  updatedAt: DateTime!
}

type ApplicationWorkshopCount {
  presenters: Int!
}

input ApplicationWorkshopRelationFilter {
  is: ApplicationWorkshopWhereInput
  isNot: ApplicationWorkshopWhereInput
}

input ApplicationWorkshopWhereInput {
  AND: [ApplicationWorkshopWhereInput!]
  NOT: [ApplicationWorkshopWhereInput!]
  OR: [ApplicationWorkshopWhereInput!]
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  goal: StringFilter
  language: StringFilter
  notesEn: StringFilter
  notesHr: StringFilter
  titleEn: StringFilter
  titleHr: StringFilter
}

type AuthResponse {
  entity: User
  errors: [FieldError!]
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Booth {
  key: String
  name: String!
}

type Company {
  _count: CompanyCount
  address: String!
  brandName: String!
  createdAt: DateTime!
  descriptionEn: String!
  descriptionHr: String!
  industry: Industry
  legalName: String!
  members: [User!]
  rasterLogo: Image
  uid: String!
  updatedAt: DateTime!
  vat: String!
  vectorLogo: File
  website: String!
}

type CompanyApplication {
  booth: String
  createdAt: DateTime!
  talk: ApplicationTalk
  updatedAt: DateTime!
  wantsCocktail: Boolean!
  wantsPanel: Boolean!
  workshop: ApplicationWorkshop
}

input CompanyApplicationCreateInput {
  booth: String = null
  talk: TalkCreateInput = null
  vat: String = ""
  wantsCocktail: Boolean = false
  wantsPanel: Boolean = false
  workshop: WorkshopCreateInput = null
}

input CompanyApplicationListRelationFilter {
  every: CompanyApplicationWhereInput
  none: CompanyApplicationWhereInput
  some: CompanyApplicationWhereInput
}

input CompanyApplicationOrderByRelationAggregateInput {
  _count: SortOrder
}

input CompanyApplicationWhereInput {
  AND: [CompanyApplicationWhereInput!]
  NOT: [CompanyApplicationWhereInput!]
  OR: [CompanyApplicationWhereInput!]
  booth: StringNullableFilter
  forCompany: CompanyRelationFilter
  forSeason: SeasonRelationFilter
  talk: ApplicationTalkRelationFilter
  wantsCocktail: BoolFilter
  wantsPanel: BoolFilter
  workshop: ApplicationWorkshopRelationFilter
}

type CompanyCount {
  applications: Int!
  members: Int!
}

input CompanyOrderByWithRelationInput {
  address: SortOrder
  brandName: SortOrder
  descriptionEn: SortOrder
  descriptionHr: SortOrder
  legalName: SortOrder
  vat: SortOrder
  website: SortOrder
}

input CompanyRelationFilter {
  is: CompanyWhereInput
  isNot: CompanyWhereInput
}

enum CompanyScalarFieldEnum {
  address
  brandName
  createdAt
  descriptionEn
  descriptionHr
  id
  industryId
  legalName
  rasterLogoId
  uid
  updatedAt
  vat
  vectorLogoId
  website
}

input CompanyWhereInput {
  AND: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  address: StringFilter
  brandName: StringFilter
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  legalName: StringFilter
  vat: StringFilter
  website: StringFilter
}

input CompanyWhereUniqueInput {
  vat: String
}

type CreateCompanyApplicationResponse {
  entity: CompanyApplication
  errors: [FieldError!]
}

input CreateCompanyInput {
  address: String!
  brandName: String!
  descriptionEn: String!
  descriptionHr: String!
  industry: String = ""
  legalName: String!
  rasterLogo: Upload = null
  vat: String!
  vectorLogo: Upload = null
  website: String!
}

type CreateCompanyResponse {
  entity: Company
  errors: [FieldError!]
}

type CreatePressReleaseResponse {
  entity: PressRelease
  errors: [FieldError!]
}

# The javascript `Date` as string. Type represents date and time as the ISO Date string.
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

type FieldError {
  field: String!
  message: String!
}

type File {
  _count: FileCount
  createdAt: DateTime!
  etag: String!
  mimeType: String!
  name: String!
  size: Int!
  uid: String!
  updatedAt: DateTime!
}

type FileCount {
  forCompany: Int!
  forPressRelease: Int!
}

input FileOrderByWithRelationInput {
  etag: SortOrder
  mimeType: SortOrder
  name: SortOrder
  size: SortOrder
  uploader: UserOrderByWithRelationInput
}

input FileRelationFilter {
  is: FileWhereInput
  isNot: FileWhereInput
}

input FileWhereInput {
  AND: [FileWhereInput!]
  NOT: [FileWhereInput!]
  OR: [FileWhereInput!]
  etag: StringFilter
  mimeType: StringFilter
  name: StringFilter
  size: IntFilter
  uploader: UserRelationFilter
}

type Image {
  _count: ImageCount
  createdAt: DateTime!
  full: ImageVariation!
  name: String!
  thumb: ImageVariation!
  uid: String!
  updatedAt: DateTime!
}

type ImageCount {
  ApplicationPresenter: Int!
  Company: Int!
}

type ImageVariation {
  _count: ImageVariationCount
  etag: String!
  mimeType: String!
}

type ImageVariationCount {
  forFull: Int!
  forOriginal: Int!
  forThumb: Int!
}

type Industry {
  _count: IndustryCount
  name: String!
}

type IndustryCount {
  company: Int!
}

input IndustryOrderByWithRelationInput {
  name: SortOrder
}

enum IndustryScalarFieldEnum {
  id
  name
}

input IndustryWhereInput {
  AND: [IndustryWhereInput!]
  NOT: [IndustryWhereInput!]
  OR: [IndustryWhereInput!]
  name: StringFilter
}

input IndustryWhereUniqueInput {
  name: String
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type Mutation {
  createCompanyApplication(info: CompanyApplicationCreateInput!): CreateCompanyApplicationResponse
  createIndustry(name: String!): Industry
  createPressRelease(info: PressReleaseWithFilesCreateInput!): CreatePressReleaseResponse
  createSeason(info: SeasonCreateInput!): Season
  createTalkCategory(name: String!): ApplicationTalkCategory
  deleteSeason(uid: String!): Season
  login(identifier: String!, password: String!): AuthResponse!
  logout: Boolean!
  register(info: UserRegisterInput!): AuthResponse!
  registerCompany(info: CreateCompanyInput!): CreateCompanyResponse
  renameIndustry(newName: String!, oldName: String!): Industry
  renameTalkCategory(newName: String!, oldName: String!): ApplicationTalkCategory
  updateCompanyInfo(info: CreateCompanyInput!): CreateCompanyResponse
  updatePassword(currentPassword: String!, newPassword: String!, newPasswordRepeat: String!): UpdatePasswordResponse
  updatePressRelease(info: PressReleaseWithFilesCreateInput!, uid: String!): CreatePressReleaseResponse
  updateProfile(info: UserCreateInput!): UpdateProfileResponse
  updateSeason(info: SeasonUpdateInput!): Season
  updateTranslation(data: TranslationCreateInput!): Translation
  updateUser(info: UserUpdateInput!, uid: String!): UpdateProfileResponse
  validateVat(vat: String!): ValidateVatResponse!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type News {
  content: String!
  date: DateTime!
  description: String!
  image: String!
  lang: String!
  slug: String!
  title: String!
}

input PresenterCreateInput {
  bioEn: String = ""
  bioHr: String = ""
  firstName: String = ""
  lastName: String = ""
  photo: Upload = null
}

type PressRelease {
  createdAt: DateTime!
  file: File
  published: DateTime!
  title: String!
  uid: String!
  updatedAt: DateTime!
}

input PressReleaseOrderByWithRelationInput {
  creator: UserOrderByWithRelationInput
  file: FileOrderByWithRelationInput
  published: SortOrder
  title: SortOrder
}

enum PressReleaseScalarFieldEnum {
  createdAt
  creatorId
  fileId
  id
  published
  title
  uid
  updatedAt
}

input PressReleaseWhereInput {
  AND: [PressReleaseWhereInput!]
  NOT: [PressReleaseWhereInput!]
  OR: [PressReleaseWhereInput!]
  creator: UserRelationFilter
  file: FileRelationFilter
  published: DateTimeFilter
  title: StringFilter
}

input PressReleaseWhereUniqueInput {
  uid: String = ""
}

input PressReleaseWithFilesCreateInput {
  file: Upload = null
  published: DateTime = null
  title: String = ""
}

type Query {
  allTranslationsFor(language: String!): [Translation!]!
  booths: [Booth!]!
  companies(cursor: CompanyWhereUniqueInput, distinct: [CompanyScalarFieldEnum!], orderBy: [CompanyOrderByWithRelationInput!], skip: Int, take: Int, where: CompanyWhereInput): [Company!]!
  company(vat: String!): Company
  companyApplication: CompanyApplication
  currentSeason: Season
  findFirstTranslation(cursor: TranslationWhereUniqueInput, distinct: [TranslationScalarFieldEnum!], orderBy: [TranslationOrderByWithRelationInput!], skip: Int, take: Int, where: TranslationWhereInput): Translation
  industries(cursor: IndustryWhereUniqueInput, distinct: [IndustryScalarFieldEnum!], orderBy: [IndustryOrderByWithRelationInput!], skip: Int, take: Int, where: IndustryWhereInput): [Industry!]!
  news(lang: String!): [News!]!
  newsItem(slug: String!): News
  pressRelease(uid: String!): PressRelease
  pressReleases(cursor: PressReleaseWhereUniqueInput, distinct: [PressReleaseScalarFieldEnum!], orderBy: [PressReleaseOrderByWithRelationInput!], skip: Int, take: Int, where: PressReleaseWhereInput): [PressRelease!]!
  profile: User
  roles(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): [Role!]!
  seasons(cursor: SeasonWhereUniqueInput, distinct: [SeasonScalarFieldEnum!], orderBy: [SeasonOrderByWithRelationInput!], skip: Int, take: Int, where: SeasonWhereInput): [Season!]!
  talkCategories(cursor: ApplicationTalkCategoryWhereUniqueInput, distinct: [ApplicationTalkCategoryScalarFieldEnum!], orderBy: [ApplicationTalkCategoryOrderByWithRelationInput!], skip: Int, take: Int, where: ApplicationTalkCategoryWhereInput): [ApplicationTalkCategory!]!
  translation(where: TranslationWhereUniqueInput!): Translation
  translations(cursor: TranslationWhereUniqueInput, distinct: [TranslationScalarFieldEnum!], orderBy: [TranslationOrderByWithRelationInput!], skip: Int, take: Int, where: TranslationWhereInput): [Translation!]!
  user(uid: String!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type Role {
  _count: RoleCount
  createdAt: DateTime!
  name: String!
  updatedAt: DateTime!
}

type RoleCount {
  users: Int!
}

input RoleOrderByWithRelationInput {
  name: SortOrder
}

enum RoleScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  name: StringFilter
}

input RoleWhereUniqueInput {
  name: String
}

type Season {
  _count: SeasonCount
  endsAt: DateTime!
  name: String!
  startsAt: DateTime!
  uid: String!
}

type SeasonCount {
  companies: Int!
}

input SeasonCreateInput {
  endsAt: DateTime = null
  name: String = ""
  startsAt: DateTime = null
}

input SeasonOrderByWithRelationInput {
  companies: CompanyApplicationOrderByRelationAggregateInput
  endsAt: SortOrder
  name: SortOrder
  startsAt: SortOrder
  uid: SortOrder
}

input SeasonRelationFilter {
  is: SeasonWhereInput
  isNot: SeasonWhereInput
}

enum SeasonScalarFieldEnum {
  endsAt
  id
  name
  startsAt
  uid
}

input SeasonUpdateInput {
  endsAt: DateTime = null
  name: String = ""
  startsAt: DateTime = null
  uid: String = ""
}

input SeasonWhereInput {
  AND: [SeasonWhereInput!]
  NOT: [SeasonWhereInput!]
  OR: [SeasonWhereInput!]
  companies: CompanyApplicationListRelationFilter
  endsAt: DateTimeFilter
  name: StringFilter
  startsAt: DateTimeFilter
  uid: StringFilter
}

input SeasonWhereUniqueInput {
  uid: String
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input TalkCreateInput {
  category: String = ""
  descriptionEn: String = ""
  descriptionHr: String = ""
  language: String = ""
  presenter: PresenterCreateInput = null
  titleEn: String = ""
  titleHr: String = ""
}

type Translation {
  createdAt: DateTime!
  key: String!
  language: String!
  updatedAt: DateTime!
  value: String!
}

input TranslationCreateInput {
  key: String!
  language: String!
  value: String!
}

input TranslationKeyLanguageCompoundUniqueInput {
  key: String!
  language: String!
}

input TranslationOrderByWithRelationInput {
  key: SortOrder
  language: SortOrder
  value: SortOrder
}

enum TranslationScalarFieldEnum {
  createdAt
  key
  language
  updatedAt
  value
}

input TranslationWhereInput {
  AND: [TranslationWhereInput!]
  NOT: [TranslationWhereInput!]
  OR: [TranslationWhereInput!]
  key: StringFilter
  language: StringFilter
  value: StringFilter
}

input TranslationWhereUniqueInput {
  key_language: TranslationKeyLanguageCompoundUniqueInput
}

type UpdatePasswordResponse {
  entity: User
  errors: [FieldError!]
}

type UpdateProfileResponse {
  entity: User
  errors: [FieldError!]
}

# The `Upload` scalar type represents a file upload.
scalar Upload

type User {
  _count: UserCount
  companies: [Company!]!
  createdAt: DateTime!
  email: String!
  firstName: String!
  lastName: String!
  name: String!
  phone: String!
  roles: [Role!]!
  uid: String!
  updatedAt: DateTime!
}

type UserCount {
  companies: Int!
  events: Int!
  files: Int!
  images: Int!
  pressReleases: Int!
  roles: Int!
}

input UserCreateInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  phone: String!
}

input UserOrderByWithRelationInput {
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
}

input UserRegisterInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  passwordRepeat: String = ""
  phone: String!
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  firstName
  id
  lastName
  password
  phone
  uid
  updatedAt
}

input UserUpdateInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  phone: String!
  roles: [String!] = []
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  email: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
}

input UserWhereUniqueInput {
  email: String
}

type ValidateVatResponse {
  exists: Boolean!
  info: VatData
  valid: Boolean!
}

type VatData {
  address: String!
  legalName: String!
}

input WorkshopCreateInput {
  descriptionEn: String = ""
  descriptionHr: String = ""
  goal: String = ""
  language: String = ""
  notesEn: String = ""
  notesHr: String = ""
  presenter: PresenterCreateInput = null
  titleEn: String = ""
  titleHr: String = ""
}

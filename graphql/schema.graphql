# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AuthResponse {
  entity: User
  errors: [FieldError!]
}

type Company {
  _count: CompanyCount
  address: String!
  brandName: String!
  descriptionEn: String!
  descriptionHr: String!
  industry: Industry
  legalName: String!
  members: [User!]!
  uid: String!
  vat: String!
  website: String!
}

type CompanyCount {
  usersCompanies: Int!
}

input CompanyOrderByWithRelationInput {
  address: SortOrder
  brandName: SortOrder
  descriptionEn: SortOrder
  descriptionHr: SortOrder
  legalName: SortOrder
  vat: SortOrder
  website: SortOrder
}

enum CompanyScalarFieldEnum {
  address
  brandName
  descriptionEn
  descriptionHr
  id
  industryId
  legalName
  uid
  vat
  website
}

input CompanyWhereInput {
  AND: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  address: StringFilter
  brandName: StringFilter
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  legalName: StringFilter
  vat: StringFilter
  website: StringFilter
}

input CompanyWhereUniqueInput {
  vat: String
}

input CreateCompanyInput {
  address: String!
  brandName: String!
  descriptionEn: String!
  descriptionHr: String!
  industry: String = ""
  legalName: String!
  vat: String!
  website: String!
}

type CreateCompanyResponse {
  entity: Company
  errors: [FieldError!]
}

type CreatePressReleaseResponse {
  entity: PressRelease
  errors: [FieldError!]
}

# The javascript `Date` as string. Type represents date and time as the ISO Date string.
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

type FieldError {
  field: String!
  message: String!
}

type File {
  _count: FileCount
  createdAt: DateTime!
  etag: String!
  mimeType: String!
  name: String!
  size: Int!
  uid: String!
  updatedAt: DateTime!
}

type FileCount {
  forPressRelease: Int!
}

input FileOrderByWithRelationInput {
  etag: SortOrder
  mimeType: SortOrder
  name: SortOrder
  size: SortOrder
  uploader: UserOrderByWithRelationInput
}

input FileRelationFilter {
  is: FileWhereInput
  isNot: FileWhereInput
}

input FileWhereInput {
  AND: [FileWhereInput!]
  NOT: [FileWhereInput!]
  OR: [FileWhereInput!]
  etag: StringFilter
  mimeType: StringFilter
  name: StringFilter
  size: IntFilter
  uploader: UserRelationFilter
}

type Industry {
  _count: IndustryCount
  name: String!
}

type IndustryCount {
  company: Int!
}

input IndustryOrderByWithRelationInput {
  name: SortOrder
}

enum IndustryScalarFieldEnum {
  id
  name
}

input IndustryWhereInput {
  AND: [IndustryWhereInput!]
  NOT: [IndustryWhereInput!]
  OR: [IndustryWhereInput!]
  name: StringFilter
}

input IndustryWhereUniqueInput {
  name: String
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type Mutation {
  createIndustry(name: String!): Industry
  createPressRelease(info: PressReleaseWithFilesCreateInput!): CreatePressReleaseResponse
  login(identifier: String!, password: String!): AuthResponse!
  logout: Boolean!
  register(info: UserRegisterInput!): AuthResponse!
  registerCompany(info: CreateCompanyInput!): CreateCompanyResponse
  renameIndustry(newName: String!, oldName: String!): Industry
  updateCompanyInfo(info: CreateCompanyInput!): CreateCompanyResponse
  updatePassword(currentPassword: String!, newPassword: String!, newPasswordRepeat: String!): UpdatePasswordResponse
  updatePressRelease(info: PressReleaseWithFilesCreateInput!, uid: String!): CreatePressReleaseResponse
  updateProfile(info: UserCreateInput!): UpdateProfileResponse
  updateTranslation(data: TranslationCreateInput!): Translation
  validateVat(vat: String!): ValidateVatResponse!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type PressRelease {
  createdAt: DateTime!
  file: File
  published: DateTime!
  title: String!
  uid: String!
  updatedAt: DateTime!
}

input PressReleaseOrderByWithRelationInput {
  creator: UserOrderByWithRelationInput
  file: FileOrderByWithRelationInput
  published: SortOrder
  title: SortOrder
}

enum PressReleaseScalarFieldEnum {
  createdAt
  creatorId
  fileId
  id
  published
  title
  uid
  updatedAt
}

input PressReleaseWhereInput {
  AND: [PressReleaseWhereInput!]
  NOT: [PressReleaseWhereInput!]
  OR: [PressReleaseWhereInput!]
  creator: UserRelationFilter
  file: FileRelationFilter
  published: DateTimeFilter
  title: StringFilter
}

input PressReleaseWhereUniqueInput {
  uid: String = ""
}

input PressReleaseWithFilesCreateInput {
  file: Upload = null
  published: DateTime = null
  title: String = ""
}

type Query {
  allTranslationsFor(language: String!): [Translation!]!
  companies(cursor: CompanyWhereUniqueInput, distinct: [CompanyScalarFieldEnum!], orderBy: [CompanyOrderByWithRelationInput!], skip: Int, take: Int, where: CompanyWhereInput): [Company!]!
  company(vat: String!): Company
  findFirstTranslation(cursor: TranslationWhereUniqueInput, distinct: [TranslationScalarFieldEnum!], orderBy: [TranslationOrderByWithRelationInput!], skip: Int, take: Int, where: TranslationWhereInput): Translation
  industries(cursor: IndustryWhereUniqueInput, distinct: [IndustryScalarFieldEnum!], orderBy: [IndustryOrderByWithRelationInput!], skip: Int, take: Int, where: IndustryWhereInput): [Industry!]!
  pressRelease(uid: String!): PressRelease
  pressReleases(cursor: PressReleaseWhereUniqueInput, distinct: [PressReleaseScalarFieldEnum!], orderBy: [PressReleaseOrderByWithRelationInput!], skip: Int, take: Int, where: PressReleaseWhereInput): [PressRelease!]!
  profile: User
  translation(where: TranslationWhereUniqueInput!): Translation
  translations(cursor: TranslationWhereUniqueInput, distinct: [TranslationScalarFieldEnum!], orderBy: [TranslationOrderByWithRelationInput!], skip: Int, take: Int, where: TranslationWhereInput): [Translation!]!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type Role {
  _count: RoleCount
  createdAt: DateTime!
  name: String!
  updatedAt: DateTime!
}

type RoleCount {
  usersRoles: Int!
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Translation {
  createdAt: DateTime!
  key: String!
  language: String!
  updatedAt: DateTime!
  value: String!
}

input TranslationCreateInput {
  key: String!
  language: String!
  value: String!
}

input TranslationKeyLanguageCompoundUniqueInput {
  key: String!
  language: String!
}

input TranslationOrderByWithRelationInput {
  key: SortOrder
  language: SortOrder
  value: SortOrder
}

enum TranslationScalarFieldEnum {
  createdAt
  key
  language
  updatedAt
  value
}

input TranslationWhereInput {
  AND: [TranslationWhereInput!]
  NOT: [TranslationWhereInput!]
  OR: [TranslationWhereInput!]
  key: StringFilter
  language: StringFilter
  value: StringFilter
}

input TranslationWhereUniqueInput {
  key_language: TranslationKeyLanguageCompoundUniqueInput
}

type UpdatePasswordResponse {
  entity: User
  errors: [FieldError!]
}

type UpdateProfileResponse {
  entity: User
  errors: [FieldError!]
}

# The `Upload` scalar type represents a file upload.
scalar Upload

type User {
  _count: UserCount
  companies: [Company!]!
  createdAt: DateTime!
  email: String!
  firstName: String!
  lastName: String!
  name: String!
  phone: String!
  roles: [Role!]!
  uid: String!
  updatedAt: DateTime!
}

type UserCount {
  events: Int!
  files: Int!
  pressReleases: Int!
  usersCompanies: Int!
  usersRoles: Int!
}

input UserCreateInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  phone: String!
}

input UserOrderByWithRelationInput {
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
}

input UserRegisterInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  passwordRepeat: String = ""
  phone: String!
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  firstName
  id
  lastName
  password
  phone
  uid
  updatedAt
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  email: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
}

input UserWhereUniqueInput {
  email: String
}

type ValidateVatResponse {
  exists: Boolean!
  info: VatData
  valid: Boolean!
}

type VatData {
  address: String!
  legalName: String!
}

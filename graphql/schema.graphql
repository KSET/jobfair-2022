# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type ApplicationCocktailCategory {
  colour: String!
  forSeason: Season
  ingredients: String!
  name: String!
}

input ApplicationCocktailCategoryListRelationFilter {
  every: ApplicationCocktailCategoryWhereInput
  none: ApplicationCocktailCategoryWhereInput
  some: ApplicationCocktailCategoryWhereInput
}

input ApplicationCocktailCategoryNullableRelationFilter {
  is: ApplicationCocktailCategoryWhereInput
  isNot: ApplicationCocktailCategoryWhereInput
}

input ApplicationCocktailCategoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input ApplicationCocktailCategoryOrderByWithRelationInput {
  colour: SortOrder
  forSeason: SeasonOrderByWithRelationInput
  ingredients: SortOrder
  name: SortOrder
}

input ApplicationCocktailCategoryWhereInput {
  AND: [ApplicationCocktailCategoryWhereInput!]
  NOT: [ApplicationCocktailCategoryWhereInput!]
  OR: [ApplicationCocktailCategoryWhereInput!]
  colour: StringFilter
  forSeason: SeasonNullableRelationFilter
  ingredients: StringFilter
  name: StringFilter
}

type ApplicationPresenter {
  _count: ApplicationPresenterCount
  bioEn: String!
  bioHr: String!
  createdAt: DateTimeISO!
  firstName: String!
  lastName: String!
  photo: Image
  updatedAt: DateTimeISO!
}

type ApplicationPresenterCount {
  forPanels(where: CompanyApplicationWhereInput): Int!
  forTalks(where: ApplicationTalkWhereInput): Int!
  forWorkshops(where: ApplicationWorkshopWhereInput): Int!
}

input ApplicationPresenterListRelationFilter {
  every: ApplicationPresenterWhereInput
  none: ApplicationPresenterWhereInput
  some: ApplicationPresenterWhereInput
}

input ApplicationPresenterOrderByRelationAggregateInput {
  _count: SortOrder
}

input ApplicationPresenterWhereInput {
  AND: [ApplicationPresenterWhereInput!]
  NOT: [ApplicationPresenterWhereInput!]
  OR: [ApplicationPresenterWhereInput!]
  bioEn: StringFilter
  bioHr: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  photo: ImageNullableRelationFilter
}

type ApplicationTalk {
  _count: ApplicationTalkCount
  category: ApplicationTalkCategory!
  createdAt: DateTimeISO!
  descriptionEn: String!
  descriptionHr: String!
  event: CalendarItem
  language: String!
  presenters: [ApplicationPresenter!]!
  reservation: Float!
  titleEn: String!
  titleHr: String!
  uid: String!
  updatedAt: DateTimeISO!
}

type ApplicationTalkCategory {
  _count: ApplicationTalkCategoryCount
  forSeason: Season
  name: String!
}

type ApplicationTalkCategoryCount {
  talks(where: ApplicationTalkWhereInput): Int!
}

input ApplicationTalkCategoryForSeasonIdNameCompoundUniqueInput {
  forSeasonId: Int!
  name: String!
}

input ApplicationTalkCategoryOrderByWithRelationInput {
  forSeason: SeasonOrderByWithRelationInput
  name: SortOrder
}

input ApplicationTalkCategoryRelationFilter {
  is: ApplicationTalkCategoryWhereInput
  isNot: ApplicationTalkCategoryWhereInput
}

enum ApplicationTalkCategoryScalarFieldEnum {
  forSeasonId
  id
  name
}

input ApplicationTalkCategoryWhereInput {
  AND: [ApplicationTalkCategoryWhereInput!]
  NOT: [ApplicationTalkCategoryWhereInput!]
  OR: [ApplicationTalkCategoryWhereInput!]
  forSeason: SeasonNullableRelationFilter
  name: StringFilter
}

input ApplicationTalkCategoryWhereUniqueInput {
  AND: [ApplicationTalkCategoryWhereInput!]
  NOT: [ApplicationTalkCategoryWhereInput!]
  OR: [ApplicationTalkCategoryWhereInput!]
  forSeason: SeasonNullableRelationFilter
  forSeasonId_name: ApplicationTalkCategoryForSeasonIdNameCompoundUniqueInput
  name: StringFilter
}

type ApplicationTalkCount {
  presenters(where: ApplicationPresenterWhereInput): Int!
}

input ApplicationTalkNullableRelationFilter {
  is: ApplicationTalkWhereInput
  isNot: ApplicationTalkWhereInput
}

input ApplicationTalkOrderByWithRelationInput {
  category: ApplicationTalkCategoryOrderByWithRelationInput
  descriptionEn: SortOrder
  descriptionHr: SortOrder
  event: CalendarItemOrderByWithRelationInput
  language: SortOrder
  titleEn: SortOrder
  titleHr: SortOrder
}

input ApplicationTalkWhereInput {
  AND: [ApplicationTalkWhereInput!]
  NOT: [ApplicationTalkWhereInput!]
  OR: [ApplicationTalkWhereInput!]
  category: ApplicationTalkCategoryRelationFilter
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  event: CalendarItemNullableRelationFilter
  language: StringFilter
  titleEn: StringFilter
  titleHr: StringFilter
}

type ApplicationWorkshop {
  _count: ApplicationWorkshopCount
  createdAt: DateTimeISO!
  descriptionEn: String!
  descriptionHr: String!
  event: CalendarItem
  goal: String!
  language: String!
  notesEn: String!
  notesHr: String!
  presenters: [ApplicationPresenter!]!
  reservation: Float!
  titleEn: String!
  titleHr: String!
  uid: String!
  updatedAt: DateTimeISO!
}

type ApplicationWorkshopCount {
  presenters(where: ApplicationPresenterWhereInput): Int!
}

input ApplicationWorkshopNullableRelationFilter {
  is: ApplicationWorkshopWhereInput
  isNot: ApplicationWorkshopWhereInput
}

input ApplicationWorkshopOrderByWithRelationInput {
  descriptionEn: SortOrder
  descriptionHr: SortOrder
  event: CalendarItemOrderByWithRelationInput
  goal: SortOrder
  language: SortOrder
  notesEn: SortOrder
  notesHr: SortOrder
  titleEn: SortOrder
  titleHr: SortOrder
}

input ApplicationWorkshopWhereInput {
  AND: [ApplicationWorkshopWhereInput!]
  NOT: [ApplicationWorkshopWhereInput!]
  OR: [ApplicationWorkshopWhereInput!]
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  event: CalendarItemNullableRelationFilter
  goal: StringFilter
  language: StringFilter
  notesEn: StringFilter
  notesHr: StringFilter
  titleEn: StringFilter
  titleHr: StringFilter
}

input ApproveCompanyApplicationsInput {
  parts: ApproveCompanyApplicationsInputParts!
  uid: String!
}

input ApproveCompanyApplicationsInputParts {
  booth: Boolean!
  cocktail: Boolean!
  logoHidden: Boolean!
  panel: Boolean!
  talkParticipants: Float!
  workshopParticipants: Float!
}

type AuthResponse {
  entity: User
  errors: [FieldError!]
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Booth {
  key: String
  name: String!
}

type CalendarEvent {
  class: String!
  end: DateTimeISO!
  location: String!
  noGroup: Boolean!
  start: DateTimeISO!
  text: String!
  title: String!
}

input CalendarFilterInput {
  type: String
}

type CalendarItem {
  capacity: Int!
  companies: [Company!]
  end: DateTimeISO!
  forPanel: CompanyPanel
  forTalk: ApplicationTalk
  forWorkshop: ApplicationWorkshop
  grouped: Boolean!
  hasEvent: Boolean!
  location: String
  start: DateTimeISO!
  text: String
  title: String
  type: String
  uid: String!
}

input CalendarItemListRelationFilter {
  every: CalendarItemWhereInput
  none: CalendarItemWhereInput
  some: CalendarItemWhereInput
}

input CalendarItemNullableRelationFilter {
  is: CalendarItemWhereInput
  isNot: CalendarItemWhereInput
}

input CalendarItemOrderByRelationAggregateInput {
  _count: SortOrder
}

input CalendarItemOrderByWithRelationInput {
  end: SortOrder
  forSeason: SeasonOrderByWithRelationInput
  grouped: SortOrder
  location: SortOrderInput
  start: SortOrder
  text: SortOrderInput
  title: SortOrderInput
  type: SortOrderInput
}

input CalendarItemWhereInput {
  AND: [CalendarItemWhereInput!]
  NOT: [CalendarItemWhereInput!]
  OR: [CalendarItemWhereInput!]
  end: DateTimeFilter
  forSeason: SeasonRelationFilter
  grouped: BoolFilter
  location: StringNullableFilter
  start: DateTimeFilter
  text: StringNullableFilter
  title: StringNullableFilter
  type: StringNullableFilter
}

input CalendarUpdateInput {
  end: DateTimeISO!
  forUid: String
  grouped: Boolean
  location: String
  season: String!
  start: DateTimeISO!
  text: String
  title: String
  type: String
  uid: String
}

input CocktailCreateInput {
  colour: String!
  ingredients: String!
  name: String!
}

type Company {
  _count: CompanyCount
  address: String!
  brandName: String!
  createdAt: DateTimeISO!
  descriptionEn: String!
  descriptionHr: String!
  facebook: String
  industry: Industry
  instagram: String
  legalName: String!
  linkedIn: String
  logoHidden: Boolean!
  members: [User!]
  program: CompanyProgram
  rasterLogo: Image
  ratings: [UserCompanyComponentRatingComponentAverage!]!
  uid: String!
  updatedAt: DateTimeISO!
  vat: String!
  vectorLogo: File
  website: String!
}

type CompanyApplication {
  _count: CompanyApplicationCount
  approval: CompanyApplicationApproval
  booth: String
  cocktail: ApplicationCocktailCategory
  contactPerson: CompanyApplicationContactPerson
  createdAt: DateTimeISO!
  feedback: CompanyApplicationFeedback
  forCompany: Company
  forSeason: Season
  panelParticipants: [ApplicationPresenter!]!
  talk: ApplicationTalk
  updatedAt: DateTimeISO!
  userApplications: EventUserApplications!
  wantsCocktail: Boolean!
  wantsPanel: Boolean!
  workshop: ApplicationWorkshop
}

type CompanyApplicationApproval {
  booth: Boolean!
  cocktail: Boolean!
  forApplication: CompanyApplication!
  logoHidden: Boolean!
  panel: Boolean!
  talkParticipants: Int!
  workshopParticipants: Int!
}

input CompanyApplicationApprovalNullableRelationFilter {
  is: CompanyApplicationApprovalWhereInput
  isNot: CompanyApplicationApprovalWhereInput
}

input CompanyApplicationApprovalOrderByWithRelationInput {
  booth: SortOrder
  cocktail: SortOrder
  logoHidden: SortOrder
  panel: SortOrder
  talkParticipants: SortOrder
  workshopParticipants: SortOrder
}

input CompanyApplicationApprovalWhereInput {
  AND: [CompanyApplicationApprovalWhereInput!]
  NOT: [CompanyApplicationApprovalWhereInput!]
  OR: [CompanyApplicationApprovalWhereInput!]
  booth: BoolFilter
  cocktail: BoolFilter
  logoHidden: BoolFilter
  panel: BoolFilter
  talkParticipants: IntFilter
  workshopParticipants: IntFilter
}

input CompanyApplicationApprovedEditInput {
  cocktail: CocktailCreateInput
  panel: [PresenterCreateInput!]!
  talk: TalksCreateInput
  vat: String!
  workshop: WorkshopsCreateInput
}

type CompanyApplicationContactPerson {
  email: String!
  name: String!
  phone: String!
}

input CompanyApplicationContactPersonCreateInput {
  email: String!
  name: String!
  phone: String!
}

input CompanyApplicationContactPersonNullableRelationFilter {
  is: CompanyApplicationContactPersonWhereInput
  isNot: CompanyApplicationContactPersonWhereInput
}

input CompanyApplicationContactPersonOrderByWithRelationInput {
  email: SortOrder
  name: SortOrder
  phone: SortOrder
}

input CompanyApplicationContactPersonWhereInput {
  AND: [CompanyApplicationContactPersonWhereInput!]
  NOT: [CompanyApplicationContactPersonWhereInput!]
  OR: [CompanyApplicationContactPersonWhereInput!]
  email: StringFilter
  name: StringFilter
  phone: StringFilter
}

type CompanyApplicationCount {
  panelParticipants(where: ApplicationPresenterWhereInput): Int!
}

input CompanyApplicationCreateInput {
  booth: String
  contactPerson: CompanyApplicationContactPersonCreateInput!
  talk: TalkCreateInput
  vat: String!
  wantsCocktail: Boolean!
  wantsPanel: Boolean!
  workshop: WorkshopCreateInput
}

type CompanyApplicationFeedback {
  applicationComments: String!
  applicationRating: Int!
  attendanceRating: Int!
  createdAt: DateTimeISO!
  dateComments: String!
  dateRating: Int!
  experienceComments: String!
  foodRating: Int!
  mostLiked: Int!
  onsiteRating: Int!
  overallComment: String!
  overallRating: Int!
  recommended: Int!
  testimonial: String!
  timeRating: Int!
  updatedAt: DateTimeISO!
}

input CompanyApplicationFeedbackCreateInput {
  applicationComments: String
  applicationRating: Int!
  attendanceRating: Int!
  dateComments: String
  dateRating: Int!
  experienceComments: String
  foodRating: Int!
  mostLiked: Int!
  onsiteRating: Int!
  overallComment: String
  overallRating: Int!
  recommended: Int!
  testimonial: String
  timeRating: Int!
}

input CompanyApplicationForCompanyIdForSeasonIdCompoundUniqueInput {
  forCompanyId: Int!
  forSeasonId: Int!
}

input CompanyApplicationListRelationFilter {
  every: CompanyApplicationWhereInput
  none: CompanyApplicationWhereInput
  some: CompanyApplicationWhereInput
}

input CompanyApplicationOrderByRelationAggregateInput {
  _count: SortOrder
}

input CompanyApplicationOrderByWithRelationInput {
  approval: CompanyApplicationApprovalOrderByWithRelationInput
  booth: SortOrderInput
  cocktail: ApplicationCocktailCategoryOrderByWithRelationInput
  contactPerson: CompanyApplicationContactPersonOrderByWithRelationInput
  forCompany: CompanyOrderByWithRelationInput
  forSeason: SeasonOrderByWithRelationInput
  panel: CompanyPanelOrderByWithRelationInput
  panelParticipants: ApplicationPresenterOrderByRelationAggregateInput
  talk: ApplicationTalkOrderByWithRelationInput
  wantsCocktail: SortOrder
  wantsPanel: SortOrder
  workshop: ApplicationWorkshopOrderByWithRelationInput
}

enum CompanyApplicationScalarFieldEnum {
  booth
  cocktailId
  contactPersonId
  createdAt
  feedbackFormId
  forCompanyId
  forSeasonId
  id
  panelId
  updatedAt
  wantsCocktail
  wantsPanel
}

input CompanyApplicationWhereInput {
  AND: [CompanyApplicationWhereInput!]
  NOT: [CompanyApplicationWhereInput!]
  OR: [CompanyApplicationWhereInput!]
  approval: CompanyApplicationApprovalNullableRelationFilter
  booth: StringNullableFilter
  cocktail: ApplicationCocktailCategoryNullableRelationFilter
  contactPerson: CompanyApplicationContactPersonNullableRelationFilter
  forCompany: CompanyRelationFilter
  forSeason: SeasonRelationFilter
  panel: CompanyPanelNullableRelationFilter
  panelParticipants: ApplicationPresenterListRelationFilter
  talk: ApplicationTalkNullableRelationFilter
  wantsCocktail: BoolFilter
  wantsPanel: BoolFilter
  workshop: ApplicationWorkshopNullableRelationFilter
}

input CompanyApplicationWhereUniqueInput {
  AND: [CompanyApplicationWhereInput!]
  NOT: [CompanyApplicationWhereInput!]
  OR: [CompanyApplicationWhereInput!]
  approval: CompanyApplicationApprovalNullableRelationFilter
  booth: StringNullableFilter
  cocktail: ApplicationCocktailCategoryNullableRelationFilter
  contactPerson: CompanyApplicationContactPersonNullableRelationFilter
  forCompany: CompanyRelationFilter
  forCompanyId_forSeasonId: CompanyApplicationForCompanyIdForSeasonIdCompoundUniqueInput
  forSeason: SeasonRelationFilter
  panel: CompanyPanelNullableRelationFilter
  panelParticipants: ApplicationPresenterListRelationFilter
  talk: ApplicationTalkNullableRelationFilter
  wantsCocktail: BoolFilter
  wantsPanel: BoolFilter
  workshop: ApplicationWorkshopNullableRelationFilter
}

type CompanyCount {
  UserCompanyComponentRatingAveragesView(where: UserCompanyComponentRatingAveragesViewWhereInput): Int!
  UserCompanyComponentRatings(where: UserCompanyComponentRatingWhereInput): Int!
  applications(where: CompanyApplicationWhereInput): Int!
  favouriteResumes(where: FavouriteResumeWhereInput): Int!
  members(where: UserWhereInput): Int!
  scannedResumes(where: ScannedResumeWhereInput): Int!
  scannedUsers(where: CompanyScannedUserWhereInput): Int!
}

input CompanyOrderByWithRelationInput {
  address: SortOrder
  brandName: SortOrder
  descriptionEn: SortOrder
  descriptionHr: SortOrder
  facebook: SortOrderInput
  instagram: SortOrderInput
  legalName: SortOrder
  linkedIn: SortOrderInput
  vat: SortOrder
  website: SortOrder
}

type CompanyPanel {
  _count: CompanyPanelCount
  companies: [Company!]!
  description: String!
  event: CalendarItem
  name: String!
  reservation: Float!
  uid: String!
}

type CompanyPanelCount {
  companies(where: CompanyApplicationWhereInput): Int!
}

input CompanyPanelNullableRelationFilter {
  is: CompanyPanelWhereInput
  isNot: CompanyPanelWhereInput
}

input CompanyPanelOrderByWithRelationInput {
  companies: CompanyApplicationOrderByRelationAggregateInput
  description: SortOrder
  event: CalendarItemOrderByWithRelationInput
  name: SortOrder
}

input CompanyPanelUpdateInput {
  companies: [String!]!
  description: String!
  name: String!
  season: String!
  uid: String
}

input CompanyPanelWhereInput {
  AND: [CompanyPanelWhereInput!]
  NOT: [CompanyPanelWhereInput!]
  OR: [CompanyPanelWhereInput!]
  companies: CompanyApplicationListRelationFilter
  description: StringFilter
  event: CalendarItemNullableRelationFilter
  name: StringFilter
}

type CompanyProgram {
  booth: String
  cocktail: ApplicationCocktailCategory
  panel: CompanyPanel
  panelParticipants: [ApplicationPresenter!]!
  talk: ApplicationTalk
  workshop: ApplicationWorkshop
}

input CompanyRelationFilter {
  is: CompanyWhereInput
  isNot: CompanyWhereInput
}

enum CompanyScalarFieldEnum {
  address
  brandName
  createdAt
  descriptionEn
  descriptionHr
  facebook
  id
  industryId
  instagram
  legalName
  linkedIn
  rasterLogoId
  uid
  updatedAt
  vat
  vectorLogoId
  website
}

input CompanyScanUserQrRefineData {
  isStarred: Boolean
  note: String
}

type CompanyScanUserQrResponse {
  alreadyScanned: Boolean!
  error: String
  isStarred: Boolean
  note: String
  user: User
}

type CompanyScannedUser {
  isStarred: Boolean!
  note: String
  scannedAt: DateTimeISO!
  user: User
}

input CompanyScannedUserListRelationFilter {
  every: CompanyScannedUserWhereInput
  none: CompanyScannedUserWhereInput
  some: CompanyScannedUserWhereInput
}

input CompanyScannedUserOrderByRelationAggregateInput {
  _count: SortOrder
}

input CompanyScannedUserWhereInput {
  AND: [CompanyScannedUserWhereInput!]
  NOT: [CompanyScannedUserWhereInput!]
  OR: [CompanyScannedUserWhereInput!]
  isStarred: BoolFilter
  note: StringNullableFilter
  scannedAt: DateTimeFilter
}

input CompanyWhereInput {
  AND: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  address: StringFilter
  brandName: StringFilter
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  facebook: StringNullableFilter
  instagram: StringNullableFilter
  legalName: StringFilter
  linkedIn: StringNullableFilter
  vat: StringFilter
  website: StringFilter
}

input CompanyWhereUniqueInput {
  AND: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  address: StringFilter
  brandName: StringFilter
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  facebook: StringNullableFilter
  instagram: StringNullableFilter
  legalName: StringFilter
  linkedIn: StringNullableFilter
  vat: String
  website: StringFilter
}

type CreateCompanyApplicationResponse {
  entity: CompanyApplication
  errors: [FieldError!]
}

input CreateCompanyInput {
  address: String!
  brandName: String!
  descriptionEn: String!
  descriptionHr: String!
  facebook: String
  industry: String!
  instagram: String
  legalName: String!
  linkedIn: String
  rasterLogo: Upload
  vat: String!
  vectorLogo: Upload
  website: String!
}

type CreateCompanyResponse {
  entity: Company
  errors: [FieldError!]
}

type CreateGalleryImageResponse {
  entity: GalleryImage
  errors: [FieldError!]
}

type CreatePartnerResponse {
  entity: Partner
  errors: [FieldError!]
}

type CreatePressReleaseResponse {
  entity: PressRelease
  errors: [FieldError!]
}

type CreateSponsorResponse {
  entity: Sponsor
  errors: [FieldError!]
}

input DateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

input DateTimeNullableFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableFilter
  notIn: [DateTimeISO!]
}

type EditApprovedCompanyApplicationResponse {
  entity: CompanyApplication
  errors: [FieldError!]
}

input EntryResumeLogWhereInput {
  AND: [EntryResumeLogWhereInput!]
  NOT: [EntryResumeLogWhereInput!]
  OR: [EntryResumeLogWhereInput!]
  event: StringNullableFilter
  eventId: IntNullableFilter
}

type EventLog {
  data: String
  date: DateTimeISO!
  id: Int!
  name: String!
  user: User
}

input EventLogOrderByWithRelationInput {
  data: SortOrderInput
  date: String
  id: String
  name: SortOrder
  user: UserOrderByWithRelationInput
}

type EventLogPaginationResult {
  page: Int!
  perPage: Int!
  records: [EventLog!]!
  totalRecords: Int!
}

input EventLogWhereInput {
  AND: [EventLogWhereInput!]
  NOT: [EventLogWhereInput!]
  OR: [EventLogWhereInput!]
  data: StringNullableFilter
  name: StringFilter
  user: UserNullableRelationFilter
}

type EventReservationResponse {
  entity: EventReservationStatus
  errors: [FieldError!]
}

type EventReservationStatus {
  status: Int!
}

input EventReservationUpdateInput {
  id: String!
  status: Int!
  type: EventType!
}

input EventReservationWhereInput {
  AND: [EventReservationWhereInput!]
  NOT: [EventReservationWhereInput!]
  OR: [EventReservationWhereInput!]
  eventId: IntFilter
  eventType: StringFilter
  status: IntFilter
  user: UserRelationFilter
}

enum EventType {
  hotTalk
  panel
  talk
  workshop
}

type EventUserApplications {
  talk: Int!
  workshop: Int!
}

input FavouriteResumeWhereInput {
  AND: [FavouriteResumeWhereInput!]
  NOT: [FavouriteResumeWhereInput!]
  OR: [FavouriteResumeWhereInput!]
}

type FieldError {
  field: String!
  message: String!
}

type File {
  _count: FileCount
  createdAt: DateTimeISO!
  etag: String!
  mimeType: String!
  name: String!
  size: Int!
  uid: String!
  updatedAt: DateTimeISO!
  url: String!
}

type FileCount {
  forCompany(where: CompanyWhereInput): Int!
  forPressRelease(where: PressReleaseWhereInput): Int!
  forResume(where: ResumeWhereInput): Int!
}

input FileOrderByWithRelationInput {
  etag: SortOrder
  mimeType: SortOrder
  name: SortOrder
  size: SortOrder
  uploader: UserOrderByWithRelationInput
}

input FileRelationFilter {
  is: FileWhereInput
  isNot: FileWhereInput
}

input FileWhereInput {
  AND: [FileWhereInput!]
  NOT: [FileWhereInput!]
  OR: [FileWhereInput!]
  etag: StringFilter
  mimeType: StringFilter
  name: StringFilter
  size: IntFilter
  uploader: UserRelationFilter
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

type GalleryImage {
  name: String!
  order: Int!
  photo: Image
  uid: String!
  visible: Boolean!
}

input GalleryImageCreateInput {
  name: String!
  photo: Upload
  visible: Boolean!
}

input GalleryImageFilter {
  take: Int
}

input GalleryImageWhereInput {
  AND: [GalleryImageWhereInput!]
  NOT: [GalleryImageWhereInput!]
  OR: [GalleryImageWhereInput!]
  name: StringFilter
  order: IntFilter
  photo: ImageRelationFilter
  visible: BoolFilter
}

type GateGuardianLog {
  eventId: Int!
  eventType: String!
  forCalendarItem: CalendarItem
  forUser: User
  scannedAt: DateTimeISO!
  scannedBy: User
}

input GateGuardianLogListRelationFilter {
  every: GateGuardianLogWhereInput
  none: GateGuardianLogWhereInput
  some: GateGuardianLogWhereInput
}

input GateGuardianLogOrderByRelationAggregateInput {
  _count: SortOrder
}

input GateGuardianLogWhereInput {
  AND: [GateGuardianLogWhereInput!]
  NOT: [GateGuardianLogWhereInput!]
  OR: [GateGuardianLogWhereInput!]
  eventId: IntFilter
  eventType: StringFilter
}

type GateGuardianScanResponse {
  alreadyScanned: Boolean!
  error: String
  hasReservation: Boolean!
  user: User
}

type Image {
  _count: ImageCount
  createdAt: DateTimeISO!
  full: ImageVariation!
  fullUrl: String!
  name: String!
  thumb: ImageVariation!
  thumbUrl: String!
  uid: String!
  updatedAt: DateTimeISO!
}

type ImageCount {
  ApplicationPresenter(where: ApplicationPresenterWhereInput): Int!
  Company(where: CompanyWhereInput): Int!
  GalleryImage(where: GalleryImageWhereInput): Int!
  News(where: NewsWhereInput): Int!
  Partner(where: PartnerWhereInput): Int!
  Sponsor(where: SponsorWhereInput): Int!
}

input ImageNullableRelationFilter {
  is: ImageWhereInput
  isNot: ImageWhereInput
}

input ImageRelationFilter {
  is: ImageWhereInput
  isNot: ImageWhereInput
}

type ImageVariation {
  _count: ImageVariationCount
  etag: String!
  mimeType: String!
}

type ImageVariationCount {
  forFull(where: ImageWhereInput): Int!
  forOriginal(where: ImageWhereInput): Int!
  forThumb(where: ImageWhereInput): Int!
}

input ImageVariationRelationFilter {
  is: ImageVariationWhereInput
  isNot: ImageVariationWhereInput
}

input ImageVariationWhereInput {
  AND: [ImageVariationWhereInput!]
  NOT: [ImageVariationWhereInput!]
  OR: [ImageVariationWhereInput!]
  etag: StringFilter
  mimeType: StringFilter
}

input ImageWhereInput {
  AND: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  full: ImageVariationRelationFilter
  name: StringFilter
  original: ImageVariationRelationFilter
  thumb: ImageVariationRelationFilter
  uploader: UserRelationFilter
}

type Industry {
  _count: IndustryCount
  name: String!
}

type IndustryCount {
  company(where: CompanyWhereInput): Int!
}

input IndustryOrderByWithRelationInput {
  name: SortOrder
}

enum IndustryScalarFieldEnum {
  id
  name
}

input IndustryWhereInput {
  AND: [IndustryWhereInput!]
  NOT: [IndustryWhereInput!]
  OR: [IndustryWhereInput!]
  name: StringFilter
}

input IndustryWhereUniqueInput {
  AND: [IndustryWhereInput!]
  NOT: [IndustryWhereInput!]
  OR: [IndustryWhereInput!]
  name: String
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

type LiveVote {
  createdAt: DateTimeISO!
  forSeason: Season!
  forUser: User!
  option: String!
  updatedAt: DateTimeISO!
}

type LiveVoteComment {
  comment: String!
  createdAt: DateTimeISO!
  forSeason: Season!
  forUser: User!
  id: Int!
  updatedAt: DateTimeISO!
}

input LiveVoteCommentWhereInput {
  AND: [LiveVoteCommentWhereInput!]
  NOT: [LiveVoteCommentWhereInput!]
  OR: [LiveVoteCommentWhereInput!]
  comment: StringFilter
  id: IntFilter
}

type LiveVoteResult {
  option: String!
  voteCount: Int!
}

input LiveVoteWhereInput {
  AND: [LiveVoteWhereInput!]
  NOT: [LiveVoteWhereInput!]
  OR: [LiveVoteWhereInput!]
  option: StringFilter
}

type Mutation {
  addCompanyMember(email: String!): String
  approveCompanyApplications(companies: [ApproveCompanyApplicationsInput!]!, season: String!): [CompanyApplicationApproval!]!
  checkPasswordReset(token: String!): User
  createCocktailCategory(info: CocktailCreateInput!, seasonUid: String!): ApplicationCocktailCategory
  createCompanyApplication(info: CompanyApplicationCreateInput!): CreateCompanyApplicationResponse
  createCompanyApplicationFor(company: String!, info: CompanyApplicationCreateInput!, season: String!): CreateCompanyApplicationResponse
  createGalleryImage(info: GalleryImageCreateInput!): CreateGalleryImageResponse
  createIndustry(name: String!): Industry
  createLiveVote(seasonUid: String!, vote: String!): LiveVote
  createLiveVoteComment(comment: String!, seasonUid: String!): LiveVoteComment
  createNews(info: NewsCreateInput!): NewsCreateResponse
  createPartner(info: PartnerCreateInput!, season: String!): CreatePartnerResponse!
  createPressRelease(info: PressReleaseWithFilesCreateInput!): CreatePressReleaseResponse
  createSeason(info: SeasonCreateInput!): Season
  createSponsor(info: SponsorCreateInput!, season: String!): CreateSponsorResponse!
  createTalkCategory(name: String!, season: String!): ApplicationTalkCategory
  deleteCalendarItem(uid: String!): Boolean!
  deleteCompanyApplicationFor(company: String!, season: String!): Boolean!
  deleteCompanyPanel(uid: String!): Boolean!
  deleteGalleryImage(uid: String!): Boolean!
  deleteLiveVoteComment(commentId: Int!): Boolean!
  deleteNews(uid: String!): Boolean
  deletePartner(partner: String!): Boolean!
  deleteResume: Boolean!
  deleteSeason(uid: String!): Season
  deleteSponsor(sponsor: String!): Boolean!
  deleteUserCompanyComponentRating(companyUid: String!, component: String!, seasonUid: String!): Boolean!
  editApprovedCompanyApplication(info: CompanyApplicationApprovedEditInput!): EditApprovedCompanyApplicationResponse
  editGalleryImage(info: GalleryImageCreateInput!, uid: String!): CreateGalleryImageResponse
  editNews(info: NewsCreateInput!, uid: String!): NewsCreateResponse
  gateGuardianScan(eventType: String!, eventUid: String!, userUid: String!): GateGuardianScanResponse
  login(identifier: String!, password: String!): AuthResponse!
  logout: Boolean!
  register(info: UserRegisterInput!): AuthResponse!
  registerCompany(info: CreateCompanyInput!): CreateCompanyResponse
  removeCompanyMember(email: String!): String
  renameIndustry(newName: String!, oldName: String!): Industry
  renameTalkCategory(newName: String!, oldName: String!, season: String!): ApplicationTalkCategory
  requestPasswordReset(identifier: String!): String!
  requestPasswordResetFor(uid: String!): String!
  resumeEntryScan(userUid: String!): Resume
  resumeScan(userUid: String!): String
  resumeSetIsFavourite(isFavourite: Boolean!, uid: String!): Boolean!
  scanUserQr(userUid: String!): CompanyScanUserQrResponse
  scanUserQrRefine(refineData: CompanyScanUserQrRefineData!, userUid: String!): CompanyScanUserQrResponse
  swapGalleryImageOrder(orderA: Int!, orderB: Int!): Boolean!
  swapPartnerOrder(orderA: Int!, orderB: Int!, season: String!): Boolean!
  swapSponsorOrder(orderA: Int!, orderB: Int!, season: String!): Boolean!
  updateCalendarItem(input: CalendarUpdateInput!): CalendarItem
  updateCocktailCategory(cocktailName: String!, info: CocktailCreateInput!, seasonUid: String!): ApplicationCocktailCategory!
  updateCompanyApplicationFeedback(input: CompanyApplicationFeedbackCreateInput!): CompanyApplicationFeedback
  updateCompanyInfo(info: CreateCompanyInput!): CreateCompanyResponse
  updateCompanyMembersFor(company: String!, members: [String!]!): CreateCompanyResponse
  updateCompanyPanel(input: CompanyPanelUpdateInput!): CompanyPanel
  updateEventReservation(input: EventReservationUpdateInput!): EventReservationResponse
  updatePassword(currentPassword: String!, newPassword: String!, newPasswordRepeat: String!): UpdatePasswordResponse
  updatePressRelease(info: PressReleaseWithFilesCreateInput!, uid: String!): CreatePressReleaseResponse
  updateProfile(info: UserCreateInput!): UpdateProfileResponse
  updateResume(info: ResumeCreateInput!): ResumeCreateResponse
  updateScannerStatusFor(isScanner: Boolean!, uid: String!): Boolean!
  updateSeason(info: SeasonUpdateInput!): Season
  updateTranslation(data: TranslationCreateInput!): Translation
  updateUser(info: UserUpdateInput!, uid: String!): UpdateProfileResponse
  upsertUserCompanyComponentRating(comment: String, companyUid: String!, component: String!, rating: Int!, seasonUid: String!): UserCompanyComponentRating!
  usePasswordReset(info: PasswordResetUseInput!): PasswordResetUseResponse!
  validateVat(vat: String!): ValidateVatResponse!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeNullableFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableFilter
  notIn: [DateTimeISO!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type News {
  author: User
  content: String!
  createdAt: DateTimeISO!
  date: DateTimeISO!
  description: String!
  lang: String!
  photo: Image
  slug: String!
  title: String!
  uid: String!
  updatedAt: DateTimeISO!
}

input NewsCreateInput {
  content: String!
  date: DateTimeISO!
  description: String!
  lang: String!
  photo: Upload
  title: String!
}

type NewsCreateResponse {
  entity: News
  errors: [FieldError!]
}

input NewsFilter {
  take: Int
}

input NewsWhereInput {
  AND: [NewsWhereInput!]
  NOT: [NewsWhereInput!]
  OR: [NewsWhereInput!]
  content: StringFilter
  date: DateTimeFilter
  description: StringFilter
  lang: StringFilter
  title: StringFilter
}

enum NullsOrder {
  first
  last
}

type Partner {
  name: String!
  order: Int!
  photo: Image
  uid: String!
  url: String!
}

input PartnerCreateInput {
  name: String!
  photo: Upload!
  url: String!
}

input PartnerListRelationFilter {
  every: PartnerWhereInput
  none: PartnerWhereInput
  some: PartnerWhereInput
}

input PartnerOrderByRelationAggregateInput {
  _count: SortOrder
}

input PartnerWhereInput {
  AND: [PartnerWhereInput!]
  NOT: [PartnerWhereInput!]
  OR: [PartnerWhereInput!]
  forSeason: SeasonRelationFilter
  name: StringFilter
  order: IntFilter
  photo: ImageRelationFilter
  url: StringFilter
}

input PasswordResetUseInput {
  newPassword: String!
  newPasswordRepeat: String!
  token: String!
}

type PasswordResetUseResponse {
  entity: Boolean
  errors: [FieldError!]
}

input PasswordResetWhereInput {
  AND: [PasswordResetWhereInput!]
  NOT: [PasswordResetWhereInput!]
  OR: [PasswordResetWhereInput!]
}

input PresenterCreateInput {
  bioEn: String!
  bioHr: String!
  firstName: String!
  lastName: String!
  photo: Upload
}

type PressRelease {
  createdAt: DateTimeISO!
  file: File
  forSeason: Season
  published: DateTimeISO!
  title: String!
  uid: String!
  updatedAt: DateTimeISO!
}

input PressReleaseOrderByWithRelationInput {
  creator: UserOrderByWithRelationInput
  file: FileOrderByWithRelationInput
  forSeason: SeasonOrderByWithRelationInput
  published: SortOrder
  title: SortOrder
}

enum PressReleaseScalarFieldEnum {
  createdAt
  creatorId
  fileId
  forSeasonId
  id
  published
  title
  uid
  updatedAt
}

input PressReleaseWhereInput {
  AND: [PressReleaseWhereInput!]
  NOT: [PressReleaseWhereInput!]
  OR: [PressReleaseWhereInput!]
  creator: UserRelationFilter
  file: FileRelationFilter
  forSeason: SeasonNullableRelationFilter
  published: DateTimeFilter
  title: StringFilter
}

input PressReleaseWhereUniqueInput {
  AND: [PressReleaseWhereInput!]
  NOT: [PressReleaseWhereInput!]
  OR: [PressReleaseWhereInput!]
  creator: UserRelationFilter
  file: FileRelationFilter
  forSeason: SeasonNullableRelationFilter
  published: DateTimeFilter
  title: StringFilter
}

input PressReleaseWithFilesCreateInput {
  file: Upload
  published: DateTimeISO!
  season: String!
  title: String!
}

type Query {
  allGalleryImages: [GalleryImage!]!
  allNews(filter: NewsFilter): [News!]!
  allTranslationsFor(language: String!): [Translation!]!
  approvedCompanyApplications: [CompanyApplicationApproval!]!
  availableCocktailCategories: [ApplicationCocktailCategory!]!
  booths: [Booth!]!
  calendar(filter: CalendarFilterInput, season: String): [CalendarItem!]!
  calendarItem(uid: String!): CalendarItem
  calendarItemCompanyUid(uid: String!): String
  calendarOld: [CalendarEvent!]!
  companies(cursor: CompanyWhereUniqueInput, distinct: [CompanyScalarFieldEnum!], orderBy: [CompanyOrderByWithRelationInput!], skip: Int, take: Int, where: CompanyWhereInput): [Company!]!
  company(vat: String!): Company
  companyApplication: CompanyApplication
  companyApplicationFor(company: String!, season: String!): CompanyApplication
  companyApplications(cursor: CompanyApplicationWhereUniqueInput, distinct: [CompanyApplicationScalarFieldEnum!], orderBy: [CompanyApplicationOrderByWithRelationInput!], season: String, skip: Int, take: Int, where: CompanyApplicationWhereInput): [CompanyApplication!]
  companyComponentAverageRatings(companyUid: String, seasonUid: String!): [UserCompanyComponentRatingComponentAverage!]!
  companyInfo(uid: String!): Company
  currentSeason: Season
  eventLog(orderBy: [EventLogOrderByWithRelationInput!], page: Int!, perPage: Int!, where: String): EventLogPaginationResult!
  findFirstTranslation(cursor: TranslationWhereUniqueInput, distinct: [TranslationScalarFieldEnum!], orderBy: [TranslationOrderByWithRelationInput!], skip: Int, take: Int, where: TranslationWhereInput): Translation
  galleryImageItemByUid(uid: String!): GalleryImage
  galleryImages(filter: GalleryImageFilter): [GalleryImage!]!
  gateGuardianScanList(season: String!): [GateGuardianLog!]
  industries(cursor: IndustryWhereUniqueInput, distinct: [IndustryScalarFieldEnum!], orderBy: [IndustryOrderByWithRelationInput!], skip: Int, take: Int, where: IndustryWhereInput): [Industry!]!
  liveVoteComments(seasonUid: String!): [LiveVoteComment!]!
  liveVoteResults(seasonUid: String!): [LiveVoteResult!]!
  liveVotes(seasonUid: String!): [LiveVote!]!
  myLiveVote(seasonUid: String!): LiveVote
  myLiveVoteComments(seasonUid: String!): [LiveVoteComment!]!
  news(filter: NewsFilter, lang: String!): [News!]!
  newsItem(slug: String!): News
  newsItemByUid(uid: String!): News
  participants(cursor: CompanyWhereUniqueInput, distinct: [CompanyScalarFieldEnum!], orderBy: [CompanyOrderByWithRelationInput!], season: String, skip: Int, take: Int, where: CompanyWhereInput): [Company!]!
  partners(season: String): [Partner!]!
  pressRelease(uid: String!): PressRelease
  pressReleases(cursor: PressReleaseWhereUniqueInput, distinct: [PressReleaseScalarFieldEnum!], orderBy: [PressReleaseOrderByWithRelationInput!], skip: Int, take: Int, where: PressReleaseWhereInput): [PressRelease!]!
  profile: User
  resume(uid: String!): Resume
  resumeFavourites: [String!]!
  resumeInterests(index: Int, query: String!): SearchResponseStringArray!
  resumeIsFavourite(uid: String!): Boolean!
  resumeTechnologies(index: Int, query: String!): SearchResponseStringArray!
  resumes(filter: ResumeFindManyInput): ResumeList!
  resumesFavourites(filter: ResumeFindManyInput): ResumeList!
  resumesScanned(filter: ResumeFindManyInput): ResumeList!
  roles(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): [Role!]!
  scannedUsers(companyUid: String, seasonUid: String): [CompanyScannedUser!]!
  season(uid: String!): Season
  seasons(cursor: SeasonWhereUniqueInput, distinct: [SeasonScalarFieldEnum!], orderBy: [SeasonOrderByWithRelationInput!], skip: Int, take: Int, where: SeasonWhereInput): [Season!]!
  sessions: [Session!]!
  sessionsFor(uid: String!): [Session!]!
  sponsors(season: String): [Sponsor!]!
  talkCategories(cursor: ApplicationTalkCategoryWhereUniqueInput, distinct: [ApplicationTalkCategoryScalarFieldEnum!], orderBy: [ApplicationTalkCategoryOrderByWithRelationInput!], skip: Int, take: Int, where: ApplicationTalkCategoryWhereInput): [ApplicationTalkCategory!]!
  translation(where: TranslationWhereUniqueInput!): Translation
  translations(cursor: TranslationWhereUniqueInput, distinct: [TranslationScalarFieldEnum!], orderBy: [TranslationOrderByWithRelationInput!], skip: Int, take: Int, where: TranslationWhereInput): [Translation!]!
  user(uid: String!): User
  userCompanyComponentRating(companyUid: String!, component: String!, seasonUid: String!): UserCompanyComponentRating
  userCompanyComponentRatings(companyUid: String!, seasonUid: String!): [UserCompanyComponentRating!]!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type ReservationItem {
  count: Float!
  type: String!
  uid: String!
}

type Resume {
  _count: ResumeCount
  city: String!
  createdAt: DateTimeISO!
  cv: File
  extraField: String!
  faculty: ResumeFaculty
  interests: [String!]!
  projects: [ResumeProject!]!
  studyYears: [ResumeStudyYear!]!
  technologies: [String!]!
  uid: String!
  updatedAt: DateTimeISO!
  user: User!
  volunteerExperiences: [ResumeVolunteerExperience!]!
  workExperiences: [ResumeWorkExperience!]!
}

type ResumeCount {
  entryLog(where: EntryResumeLogWhereInput): Int!
  favouriteResumes(where: FavouriteResumeWhereInput): Int!
  interests(where: ResumeInterestWhereInput): Int!
  projects(where: ResumeProjectWhereInput): Int!
  scannedResumes(where: ScannedResumeWhereInput): Int!
  studyYears(where: ResumeStudyYearWhereInput): Int!
  technologies(where: ResumeTechnologyWhereInput): Int!
  volunteerExperiences(where: ResumeVolunteerExperienceWhereInput): Int!
  workExperiences(where: ResumeWorkExperienceWhereInput): Int!
}

input ResumeCreateCvInput {
  cv: Upload
  keepOld: Boolean!
}

input ResumeCreateInput {
  city: String!
  extraField: String
  faculty: ResumeFacultyCreateInput!
  interests: [String!]!
  pdf: ResumeCreateCvInput
  projects: [ResumeProjectCreateInput!]!
  studyYears: [ResumeStudyYearCreateInput!]!
  technologies: [String!]!
  volunteerExperiences: [ResumeVolunteerExperienceCreateInput!]!
  workExperiences: [ResumeWorkExperienceCreateInput!]!
}

type ResumeCreateResponse {
  entity: Resume
  errors: [FieldError!]
}

type ResumeFaculty {
  module: String!
  name: String!
  specialization: String!
}

input ResumeFacultyCreateInput {
  module: String!
  name: String!
}

input ResumeFacultyNullableRelationFilter {
  is: ResumeFacultyWhereInput
  isNot: ResumeFacultyWhereInput
}

input ResumeFacultyOrderByWithRelationInput {
  module: SortOrder
  name: SortOrder
  specialization: SortOrder
}

input ResumeFacultyWhereInput {
  AND: [ResumeFacultyWhereInput!]
  NOT: [ResumeFacultyWhereInput!]
  OR: [ResumeFacultyWhereInput!]
  module: StringFilter
  name: StringFilter
  specialization: StringFilter
}

input ResumeFindManyInput {
  orderBy: [ResumeOrderByWithRelationInput!]
  skip: Int
  take: Int
  where: ResumeWhereInput
  whereUser: String
}

input ResumeInterestListRelationFilter {
  every: ResumeInterestWhereInput
  none: ResumeInterestWhereInput
  some: ResumeInterestWhereInput
}

input ResumeInterestOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResumeInterestWhereInput {
  AND: [ResumeInterestWhereInput!]
  NOT: [ResumeInterestWhereInput!]
  OR: [ResumeInterestWhereInput!]
  name: StringFilter
}

type ResumeList {
  items: [Resume!]!
  total: Int!
}

input ResumeOrderByWithRelationInput {
  city: SortOrder
  extraField: SortOrder
  faculty: ResumeFacultyOrderByWithRelationInput
  interests: ResumeInterestOrderByRelationAggregateInput
  projects: ResumeProjectOrderByRelationAggregateInput
  studyYears: ResumeStudyYearOrderByRelationAggregateInput
  technologies: ResumeTechnologyOrderByRelationAggregateInput
  volunteerExperiences: ResumeVolunteerExperienceOrderByRelationAggregateInput
  workExperiences: ResumeWorkExperienceOrderByRelationAggregateInput
}

type ResumeProject {
  position: String!
  project: String!
  start: DateTimeISO!
  until: DateTimeISO
}

input ResumeProjectCreateInput {
  position: String!
  project: String!
  start: DateTimeISO!
  until: DateTimeISO
}

input ResumeProjectListRelationFilter {
  every: ResumeProjectWhereInput
  none: ResumeProjectWhereInput
  some: ResumeProjectWhereInput
}

input ResumeProjectOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResumeProjectWhereInput {
  AND: [ResumeProjectWhereInput!]
  NOT: [ResumeProjectWhereInput!]
  OR: [ResumeProjectWhereInput!]
  position: StringFilter
  project: StringFilter
  start: DateTimeFilter
  until: DateTimeNullableFilter
}

type ResumeStudyYear {
  studyType: String!
  studyYear: Int!
}

input ResumeStudyYearCreateInput {
  studyType: String!
  studyYear: Float!
}

input ResumeStudyYearListRelationFilter {
  every: ResumeStudyYearWhereInput
  none: ResumeStudyYearWhereInput
  some: ResumeStudyYearWhereInput
}

input ResumeStudyYearOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResumeStudyYearWhereInput {
  AND: [ResumeStudyYearWhereInput!]
  NOT: [ResumeStudyYearWhereInput!]
  OR: [ResumeStudyYearWhereInput!]
  studyType: StringFilter
  studyYear: IntFilter
}

input ResumeTechnologyListRelationFilter {
  every: ResumeTechnologyWhereInput
  none: ResumeTechnologyWhereInput
  some: ResumeTechnologyWhereInput
}

input ResumeTechnologyOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResumeTechnologyWhereInput {
  AND: [ResumeTechnologyWhereInput!]
  NOT: [ResumeTechnologyWhereInput!]
  OR: [ResumeTechnologyWhereInput!]
  name: StringFilter
}

type ResumeVolunteerExperience {
  organisation: String!
  position: String!
  start: DateTimeISO!
  until: DateTimeISO
}

input ResumeVolunteerExperienceCreateInput {
  organisation: String!
  position: String!
  start: DateTimeISO!
  until: DateTimeISO
}

input ResumeVolunteerExperienceListRelationFilter {
  every: ResumeVolunteerExperienceWhereInput
  none: ResumeVolunteerExperienceWhereInput
  some: ResumeVolunteerExperienceWhereInput
}

input ResumeVolunteerExperienceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResumeVolunteerExperienceWhereInput {
  AND: [ResumeVolunteerExperienceWhereInput!]
  NOT: [ResumeVolunteerExperienceWhereInput!]
  OR: [ResumeVolunteerExperienceWhereInput!]
  organisation: StringFilter
  position: StringFilter
  start: DateTimeFilter
  until: DateTimeNullableFilter
}

input ResumeWhereInput {
  AND: [ResumeWhereInput!]
  NOT: [ResumeWhereInput!]
  OR: [ResumeWhereInput!]
  city: StringFilter
  extraField: StringFilter
  faculty: ResumeFacultyNullableRelationFilter
  interests: ResumeInterestListRelationFilter
  projects: ResumeProjectListRelationFilter
  studyYears: ResumeStudyYearListRelationFilter
  technologies: ResumeTechnologyListRelationFilter
  volunteerExperiences: ResumeVolunteerExperienceListRelationFilter
  workExperiences: ResumeWorkExperienceListRelationFilter
}

type ResumeWorkExperience {
  company: String!
  position: String!
  start: DateTimeISO!
  until: DateTimeISO
}

input ResumeWorkExperienceCreateInput {
  company: String!
  position: String!
  start: DateTimeISO!
  until: DateTimeISO
}

input ResumeWorkExperienceListRelationFilter {
  every: ResumeWorkExperienceWhereInput
  none: ResumeWorkExperienceWhereInput
  some: ResumeWorkExperienceWhereInput
}

input ResumeWorkExperienceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResumeWorkExperienceWhereInput {
  AND: [ResumeWorkExperienceWhereInput!]
  NOT: [ResumeWorkExperienceWhereInput!]
  OR: [ResumeWorkExperienceWhereInput!]
  company: StringFilter
  position: StringFilter
  start: DateTimeFilter
  until: DateTimeNullableFilter
}

type Role {
  _count: RoleCount
  createdAt: DateTimeISO!
  name: String!
  updatedAt: DateTimeISO!
}

type RoleCount {
  users(where: UserWhereInput): Int!
}

input RoleOrderByWithRelationInput {
  name: SortOrder
}

enum RoleScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  name: StringFilter
}

input RoleWhereUniqueInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  name: String
}

input ScannedResumeWhereInput {
  AND: [ScannedResumeWhereInput!]
  NOT: [ScannedResumeWhereInput!]
  OR: [ScannedResumeWhereInput!]
}

type SearchResponseStringArray {
  entities: [String!]!
  index: Float!
}

type Season {
  _count: SeasonCount
  applications: [CompanyApplication!]!
  applicationsEditableFrom: DateTimeISO!
  applicationsEditableUntil: DateTimeISO!
  applicationsFrom: DateTimeISO!
  applicationsUntil: DateTimeISO!
  calendar: [CalendarItem!]!
  companyComponentAverageRatings: [UserCompanyComponentRatingComponentAverage!]!
  companyScannedCvs: Int!
  endsAt: DateTimeISO!
  entryCount: Int!
  eventFrom: DateTimeISO!
  eventUntil: DateTimeISO!
  feedbackFrom: DateTimeISO!
  feedbackUntil: DateTimeISO!
  name: String!
  panel: CompanyPanel
  reservations: [ReservationItem!]!
  scheduleFrom: DateTimeISO!
  scheduleUntil: DateTimeISO!
  showParticipantsFrom: DateTimeISO!
  showParticipantsUntil: DateTimeISO!
  showPartnersFrom: DateTimeISO!
  showPartnersUntil: DateTimeISO!
  showSponsorsFrom: DateTimeISO!
  showSponsorsUntil: DateTimeISO!
  startsAt: DateTimeISO!
  uid: String!
}

type SeasonCount {
  ApplicationCocktailCategory(where: ApplicationCocktailCategoryWhereInput): Int!
  LiveVote(where: LiveVoteWhereInput): Int!
  LiveVoteComment(where: LiveVoteCommentWhereInput): Int!
  UserCompanyComponentRatingAveragesView(where: UserCompanyComponentRatingAveragesViewWhereInput): Int!
  UserCompanyComponentRatings(where: UserCompanyComponentRatingWhereInput): Int!
  calendar(where: CalendarItemWhereInput): Int!
  companies(where: CompanyApplicationWhereInput): Int!
  entryLog(where: EntryResumeLogWhereInput): Int!
  favouriteResumes(where: FavouriteResumeWhereInput): Int!
  gateGuardianLog(where: GateGuardianLogWhereInput): Int!
  partners(where: PartnerWhereInput): Int!
  pressReleases(where: PressReleaseWhereInput): Int!
  scannedResumes(where: ScannedResumeWhereInput): Int!
  scannedUsers(where: CompanyScannedUserWhereInput): Int!
  sponsors(where: SponsorWhereInput): Int!
  talkCategories(where: ApplicationTalkCategoryWhereInput): Int!
}

input SeasonCreateInput {
  applicationsEditableFrom: DateTimeISO!
  applicationsEditableUntil: DateTimeISO!
  applicationsFrom: DateTimeISO!
  applicationsUntil: DateTimeISO!
  endsAt: DateTimeISO!
  eventFrom: DateTimeISO!
  eventUntil: DateTimeISO!
  feedbackFrom: DateTimeISO!
  feedbackUntil: DateTimeISO!
  name: String!
  scheduleFrom: DateTimeISO!
  scheduleUntil: DateTimeISO!
  showParticipantsFrom: DateTimeISO!
  showParticipantsUntil: DateTimeISO!
  showPartnersFrom: DateTimeISO!
  showPartnersUntil: DateTimeISO!
  showSponsorsFrom: DateTimeISO!
  showSponsorsUntil: DateTimeISO!
  startsAt: DateTimeISO!
}

input SeasonNullableRelationFilter {
  is: SeasonWhereInput
  isNot: SeasonWhereInput
}

input SeasonOrderByWithRelationInput {
  ApplicationCocktailCategory: ApplicationCocktailCategoryOrderByRelationAggregateInput
  applicationsEditableFrom: SortOrder
  applicationsEditableUntil: SortOrder
  applicationsFrom: SortOrder
  applicationsUntil: SortOrder
  calendar: CalendarItemOrderByRelationAggregateInput
  companies: CompanyApplicationOrderByRelationAggregateInput
  endsAt: SortOrder
  eventFrom: SortOrder
  eventUntil: SortOrder
  feedbackFrom: SortOrder
  feedbackUntil: SortOrder
  gateGuardianLog: GateGuardianLogOrderByRelationAggregateInput
  name: SortOrder
  partners: PartnerOrderByRelationAggregateInput
  scannedUsers: CompanyScannedUserOrderByRelationAggregateInput
  scheduleFrom: SortOrder
  scheduleUntil: SortOrder
  showParticipantsFrom: SortOrder
  showParticipantsUntil: SortOrder
  showPartnersFrom: SortOrder
  showPartnersUntil: SortOrder
  showSponsorsFrom: SortOrder
  showSponsorsUntil: SortOrder
  sponsors: SponsorOrderByRelationAggregateInput
  startsAt: SortOrder
  uid: SortOrder
}

input SeasonRelationFilter {
  is: SeasonWhereInput
  isNot: SeasonWhereInput
}

enum SeasonScalarFieldEnum {
  applicationsEditableFrom
  applicationsEditableUntil
  applicationsFrom
  applicationsUntil
  endsAt
  eventFrom
  eventUntil
  feedbackFrom
  feedbackUntil
  id
  name
  scheduleFrom
  scheduleUntil
  showParticipantsFrom
  showParticipantsUntil
  showPartnersFrom
  showPartnersUntil
  showSponsorsFrom
  showSponsorsUntil
  startsAt
  uid
}

input SeasonUpdateInput {
  applicationsEditableFrom: DateTimeISO!
  applicationsEditableUntil: DateTimeISO!
  applicationsFrom: DateTimeISO!
  applicationsUntil: DateTimeISO!
  endsAt: DateTimeISO!
  eventFrom: DateTimeISO!
  eventUntil: DateTimeISO!
  feedbackFrom: DateTimeISO!
  feedbackUntil: DateTimeISO!
  name: String!
  scheduleFrom: DateTimeISO!
  scheduleUntil: DateTimeISO!
  showParticipantsFrom: DateTimeISO!
  showParticipantsUntil: DateTimeISO!
  showPartnersFrom: DateTimeISO!
  showPartnersUntil: DateTimeISO!
  showSponsorsFrom: DateTimeISO!
  showSponsorsUntil: DateTimeISO!
  startsAt: DateTimeISO!
  uid: String!
}

input SeasonWhereInput {
  AND: [SeasonWhereInput!]
  ApplicationCocktailCategory: ApplicationCocktailCategoryListRelationFilter
  NOT: [SeasonWhereInput!]
  OR: [SeasonWhereInput!]
  applicationsEditableFrom: DateTimeFilter
  applicationsEditableUntil: DateTimeFilter
  applicationsFrom: DateTimeFilter
  applicationsUntil: DateTimeFilter
  calendar: CalendarItemListRelationFilter
  companies: CompanyApplicationListRelationFilter
  endsAt: DateTimeFilter
  eventFrom: DateTimeFilter
  eventUntil: DateTimeFilter
  feedbackFrom: DateTimeFilter
  feedbackUntil: DateTimeFilter
  gateGuardianLog: GateGuardianLogListRelationFilter
  name: StringFilter
  partners: PartnerListRelationFilter
  scannedUsers: CompanyScannedUserListRelationFilter
  scheduleFrom: DateTimeFilter
  scheduleUntil: DateTimeFilter
  showParticipantsFrom: DateTimeFilter
  showParticipantsUntil: DateTimeFilter
  showPartnersFrom: DateTimeFilter
  showPartnersUntil: DateTimeFilter
  showSponsorsFrom: DateTimeFilter
  showSponsorsUntil: DateTimeFilter
  sponsors: SponsorListRelationFilter
  startsAt: DateTimeFilter
  uid: StringFilter
}

input SeasonWhereUniqueInput {
  AND: [SeasonWhereInput!]
  ApplicationCocktailCategory: ApplicationCocktailCategoryListRelationFilter
  NOT: [SeasonWhereInput!]
  OR: [SeasonWhereInput!]
  applicationsEditableFrom: DateTimeFilter
  applicationsEditableUntil: DateTimeFilter
  applicationsFrom: DateTimeFilter
  applicationsUntil: DateTimeFilter
  calendar: CalendarItemListRelationFilter
  companies: CompanyApplicationListRelationFilter
  endsAt: DateTimeFilter
  eventFrom: DateTimeFilter
  eventUntil: DateTimeFilter
  feedbackFrom: DateTimeFilter
  feedbackUntil: DateTimeFilter
  gateGuardianLog: GateGuardianLogListRelationFilter
  name: StringFilter
  partners: PartnerListRelationFilter
  scannedUsers: CompanyScannedUserListRelationFilter
  scheduleFrom: DateTimeFilter
  scheduleUntil: DateTimeFilter
  showParticipantsFrom: DateTimeFilter
  showParticipantsUntil: DateTimeFilter
  showPartnersFrom: DateTimeFilter
  showPartnersUntil: DateTimeFilter
  showSponsorsFrom: DateTimeFilter
  showSponsorsUntil: DateTimeFilter
  sponsors: SponsorListRelationFilter
  startsAt: DateTimeFilter
  uid: String
}

type Session {
  id: Int!
  ip: String!
  loggedInAt: String!
  sessionId: String!
  userAgent: String!
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

type Sponsor {
  name: String!
  order: Int!
  photo: Image
  uid: String!
  url: String!
}

input SponsorCreateInput {
  name: String!
  photo: Upload!
  url: String!
}

input SponsorListRelationFilter {
  every: SponsorWhereInput
  none: SponsorWhereInput
  some: SponsorWhereInput
}

input SponsorOrderByRelationAggregateInput {
  _count: SortOrder
}

input SponsorWhereInput {
  AND: [SponsorWhereInput!]
  NOT: [SponsorWhereInput!]
  OR: [SponsorWhereInput!]
  forSeason: SeasonRelationFilter
  name: StringFilter
  order: IntFilter
  photo: ImageRelationFilter
  url: StringFilter
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input TalkCreateInput {
  category: String!
  descriptionEn: String!
  descriptionHr: String!
  language: String!
  presenter: PresenterCreateInput!
  titleEn: String!
  titleHr: String!
}

input TalksCreateInput {
  category: String!
  descriptionEn: String!
  descriptionHr: String!
  language: String!
  presenter: [PresenterCreateInput!]!
  titleEn: String!
  titleHr: String!
}

type Translation {
  createdAt: DateTimeISO!
  key: String!
  language: String!
  updatedAt: DateTimeISO!
  value: String!
}

input TranslationCreateInput {
  key: String!
  language: String!
  value: String!
}

input TranslationKeyLanguageCompoundUniqueInput {
  key: String!
  language: String!
}

input TranslationOrderByWithRelationInput {
  key: SortOrder
  language: SortOrder
  value: SortOrder
}

enum TranslationScalarFieldEnum {
  createdAt
  key
  language
  updatedAt
  value
}

input TranslationWhereInput {
  AND: [TranslationWhereInput!]
  NOT: [TranslationWhereInput!]
  OR: [TranslationWhereInput!]
  key: StringFilter
  language: StringFilter
  value: StringFilter
}

input TranslationWhereUniqueInput {
  AND: [TranslationWhereInput!]
  NOT: [TranslationWhereInput!]
  OR: [TranslationWhereInput!]
  key: StringFilter
  key_language: TranslationKeyLanguageCompoundUniqueInput
  language: StringFilter
  value: StringFilter
}

type UpdatePasswordResponse {
  entity: User
  errors: [FieldError!]
}

type UpdateProfileResponse {
  entity: User
  errors: [FieldError!]
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  _count: UserCount
  companies: [Company!]!
  createdAt: DateTimeISO!
  email: String!
  eventLog: [EventLog!]!
  firstName: String!
  language: String!
  lastName: String!
  name: String!
  phone: String!
  resume: Resume
  roles: [Role!]!
  uid: String!
  updatedAt: DateTimeISO!
}

type UserCompanyComponentRating {
  comment: String
  component: String!
  createdAt: DateTimeISO!
  forCompany: Company!
  forSeason: Season!
  forUser: User!
  rating: Int!
  updatedAt: DateTimeISO!
}

input UserCompanyComponentRatingAveragesViewWhereInput {
  AND: [UserCompanyComponentRatingAveragesViewWhereInput!]
  NOT: [UserCompanyComponentRatingAveragesViewWhereInput!]
  OR: [UserCompanyComponentRatingAveragesViewWhereInput!]
  component: StringFilter
  ratingAvg: FloatFilter
  ratingCount: IntFilter
}

type UserCompanyComponentRatingComponentAverage {
  averageRating: Float!
  comments: [String!]!
  component: String!
  ratingCount: Int
}

input UserCompanyComponentRatingWhereInput {
  AND: [UserCompanyComponentRatingWhereInput!]
  NOT: [UserCompanyComponentRatingWhereInput!]
  OR: [UserCompanyComponentRatingWhereInput!]
  comment: StringNullableFilter
  component: StringFilter
  rating: IntFilter
}

type UserCount {
  LiveVote(where: LiveVoteWhereInput): Int!
  LiveVoteComment(where: LiveVoteCommentWhereInput): Int!
  News(where: NewsWhereInput): Int!
  UserCompanyComponentRatings(where: UserCompanyComponentRatingWhereInput): Int!
  companies(where: CompanyWhereInput): Int!
  events(where: EventLogWhereInput): Int!
  files(where: FileWhereInput): Int!
  gateGuardianEntryLog(where: GateGuardianLogWhereInput): Int!
  gateGuardianScannedLog(where: GateGuardianLogWhereInput): Int!
  images(where: ImageWhereInput): Int!
  passwordResets(where: PasswordResetWhereInput): Int!
  pressReleases(where: PressReleaseWhereInput): Int!
  reservations(where: EventReservationWhereInput): Int!
  roles(where: RoleWhereInput): Int!
  scannedEntries(where: EntryResumeLogWhereInput): Int!
  scannedUsers(where: CompanyScannedUserWhereInput): Int!
}

input UserCreateInput {
  email: String!
  firstName: String!
  language: String
  lastName: String!
  password: String!
  phone: String!
}

input UserNullableRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserOrderByWithRelationInput {
  email: SortOrder
  firstName: SortOrder
  language: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
}

input UserRegisterInput {
  email: String!
  firstName: String!
  language: String
  lastName: String!
  password: String!
  passwordRepeat: String!
  phone: String!
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  firstName
  id
  language
  lastName
  password
  phone
  resumeId
  uid
  updatedAt
}

input UserUpdateInput {
  email: String!
  firstName: String!
  language: String
  lastName: String!
  password: String!
  phone: String!
  roles: [String!]!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  email: StringFilter
  firstName: StringFilter
  language: StringFilter
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  email: String
  firstName: StringFilter
  language: StringFilter
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
}

type ValidateVatResponse {
  exists: Boolean!
  info: VatData
  valid: Boolean!
}

type VatData {
  address: String!
  legalName: String!
  vat: String!
}

input WorkshopCreateInput {
  descriptionEn: String!
  descriptionHr: String!
  goal: String!
  language: String!
  notesEn: String!
  notesHr: String!
  presenter: PresenterCreateInput!
  titleEn: String!
  titleHr: String!
}

input WorkshopsCreateInput {
  descriptionEn: String!
  descriptionHr: String!
  goal: String!
  language: String!
  notesEn: String!
  notesHr: String!
  presenter: [PresenterCreateInput!]!
  titleEn: String!
  titleHr: String!
}
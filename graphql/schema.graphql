# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type ApplicationCocktail {
  _count: ApplicationCocktailCount
  colour: String!
  forApplication: [CompanyApplication!]!
  name: String!
}

type ApplicationCocktailCount {
  forApplication: Int!
}

input ApplicationCocktailOrderByWithRelationInput {
  colour: SortOrder
  name: SortOrder
}

input ApplicationCocktailRelationFilter {
  is: ApplicationCocktailWhereInput
  isNot: ApplicationCocktailWhereInput
}

input ApplicationCocktailWhereInput {
  AND: [ApplicationCocktailWhereInput!]
  NOT: [ApplicationCocktailWhereInput!]
  OR: [ApplicationCocktailWhereInput!]
  colour: StringFilter
  name: StringFilter
}

type ApplicationPresenter {
  _count: ApplicationPresenterCount
  bioEn: String!
  bioHr: String!
  createdAt: DateTime!
  firstName: String!
  lastName: String!
  photo: Image
  updatedAt: DateTime!
}

type ApplicationPresenterCount {
  forPanels: Int!
  forTalks: Int!
  forWorkshops: Int!
}

input ApplicationPresenterListRelationFilter {
  every: ApplicationPresenterWhereInput
  none: ApplicationPresenterWhereInput
  some: ApplicationPresenterWhereInput
}

input ApplicationPresenterOrderByRelationAggregateInput {
  _count: SortOrder
}

input ApplicationPresenterWhereInput {
  AND: [ApplicationPresenterWhereInput!]
  NOT: [ApplicationPresenterWhereInput!]
  OR: [ApplicationPresenterWhereInput!]
  bioEn: StringFilter
  bioHr: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  photo: ImageRelationFilter
}

type ApplicationTalk {
  _count: ApplicationTalkCount
  category: ApplicationTalkCategory!
  createdAt: DateTime!
  descriptionEn: String!
  descriptionHr: String!
  language: String!
  presenters: [ApplicationPresenter!]!
  titleEn: String!
  titleHr: String!
  uid: String!
  updatedAt: DateTime!
}

type ApplicationTalkCategory {
  _count: ApplicationTalkCategoryCount
  name: String!
}

type ApplicationTalkCategoryCount {
  talks: Int!
}

input ApplicationTalkCategoryOrderByWithRelationInput {
  name: SortOrder
}

input ApplicationTalkCategoryRelationFilter {
  is: ApplicationTalkCategoryWhereInput
  isNot: ApplicationTalkCategoryWhereInput
}

enum ApplicationTalkCategoryScalarFieldEnum {
  id
  name
}

input ApplicationTalkCategoryWhereInput {
  AND: [ApplicationTalkCategoryWhereInput!]
  NOT: [ApplicationTalkCategoryWhereInput!]
  OR: [ApplicationTalkCategoryWhereInput!]
  name: StringFilter
}

input ApplicationTalkCategoryWhereUniqueInput {
  name: String
}

type ApplicationTalkCount {
  presenters: Int!
}

input ApplicationTalkOrderByWithRelationInput {
  category: ApplicationTalkCategoryOrderByWithRelationInput
  descriptionEn: SortOrder
  descriptionHr: SortOrder
  language: SortOrder
  titleEn: SortOrder
  titleHr: SortOrder
}

input ApplicationTalkRelationFilter {
  is: ApplicationTalkWhereInput
  isNot: ApplicationTalkWhereInput
}

input ApplicationTalkWhereInput {
  AND: [ApplicationTalkWhereInput!]
  NOT: [ApplicationTalkWhereInput!]
  OR: [ApplicationTalkWhereInput!]
  category: ApplicationTalkCategoryRelationFilter
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  language: StringFilter
  titleEn: StringFilter
  titleHr: StringFilter
}

type ApplicationWorkshop {
  _count: ApplicationWorkshopCount
  createdAt: DateTime!
  descriptionEn: String!
  descriptionHr: String!
  goal: String!
  language: String!
  notesEn: String!
  notesHr: String!
  presenters: [ApplicationPresenter!]!
  titleEn: String!
  titleHr: String!
  uid: String!
  updatedAt: DateTime!
}

type ApplicationWorkshopCount {
  presenters: Int!
}

input ApplicationWorkshopOrderByWithRelationInput {
  descriptionEn: SortOrder
  descriptionHr: SortOrder
  goal: SortOrder
  language: SortOrder
  notesEn: SortOrder
  notesHr: SortOrder
  titleEn: SortOrder
  titleHr: SortOrder
}

input ApplicationWorkshopRelationFilter {
  is: ApplicationWorkshopWhereInput
  isNot: ApplicationWorkshopWhereInput
}

input ApplicationWorkshopWhereInput {
  AND: [ApplicationWorkshopWhereInput!]
  NOT: [ApplicationWorkshopWhereInput!]
  OR: [ApplicationWorkshopWhereInput!]
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  goal: StringFilter
  language: StringFilter
  notesEn: StringFilter
  notesHr: StringFilter
  titleEn: StringFilter
  titleHr: StringFilter
}

input ApproveCompanyApplicationsInput {
  parts: ApproveCompanyApplicationsInputParts = null
  uid: String = ""
}

input ApproveCompanyApplicationsInputParts {
  booth: Boolean = false
  cocktail: Boolean = false
  panel: Boolean = false
  talkParticipants: Float = 0
  workshopParticipants: Float = 0
}

type AuthResponse {
  entity: User
  errors: [FieldError!]
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Booth {
  key: String
  name: String!
}

input CocktailCreateInput {
  colour: String = ""
  name: String = ""
}

type Company {
  _count: CompanyCount
  address: String!
  brandName: String!
  createdAt: DateTime!
  descriptionEn: String!
  descriptionHr: String!
  industry: Industry
  legalName: String!
  members: [User!]
  program: CompanyProgram
  rasterLogo: Image
  uid: String!
  updatedAt: DateTime!
  vat: String!
  vectorLogo: File
  website: String!
}

type CompanyApplication {
  _count: CompanyApplicationCount
  approval: CompanyApplicationApproval
  booth: String
  cocktail: ApplicationCocktail
  createdAt: DateTime!
  forCompany: Company
  forSeason: Season
  panelParticipants: [ApplicationPresenter!]!
  talk: ApplicationTalk
  updatedAt: DateTime!
  wantsCocktail: Boolean!
  wantsPanel: Boolean!
  workshop: ApplicationWorkshop
}

type CompanyApplicationApproval {
  booth: Boolean!
  cocktail: Boolean!
  forApplication: CompanyApplication!
  panel: Boolean!
  talkParticipants: Int!
  workshopParticipants: Int!
}

input CompanyApplicationApprovalOrderByWithRelationInput {
  booth: SortOrder
  cocktail: SortOrder
  panel: SortOrder
  talkParticipants: SortOrder
  workshopParticipants: SortOrder
}

input CompanyApplicationApprovalRelationFilter {
  is: CompanyApplicationApprovalWhereInput
  isNot: CompanyApplicationApprovalWhereInput
}

input CompanyApplicationApprovalWhereInput {
  AND: [CompanyApplicationApprovalWhereInput!]
  NOT: [CompanyApplicationApprovalWhereInput!]
  OR: [CompanyApplicationApprovalWhereInput!]
  booth: BoolFilter
  cocktail: BoolFilter
  panel: BoolFilter
  talkParticipants: IntFilter
  workshopParticipants: IntFilter
}

input CompanyApplicationApprovedEditInput {
  cocktail: CocktailCreateInput = null
  panel: [PresenterCreateInput!] = []
  talk: TalksCreateInput = null
  vat: String = ""
  workshop: WorkshopsCreateInput = null
}

type CompanyApplicationCount {
  panelParticipants: Int!
}

input CompanyApplicationCreateInput {
  booth: String = null
  talk: TalkCreateInput = null
  vat: String = ""
  wantsCocktail: Boolean = false
  wantsPanel: Boolean = false
  workshop: WorkshopCreateInput = null
}

input CompanyApplicationForCompanyIdForSeasonIdCompoundUniqueInput {
  forCompanyId: Int!
  forSeasonId: Int!
}

input CompanyApplicationListRelationFilter {
  every: CompanyApplicationWhereInput
  none: CompanyApplicationWhereInput
  some: CompanyApplicationWhereInput
}

input CompanyApplicationOrderByRelationAggregateInput {
  _count: SortOrder
}

input CompanyApplicationOrderByWithRelationInput {
  approval: CompanyApplicationApprovalOrderByWithRelationInput
  booth: SortOrder
  cocktail: ApplicationCocktailOrderByWithRelationInput
  forCompany: CompanyOrderByWithRelationInput
  forSeason: SeasonOrderByWithRelationInput
  panelParticipants: ApplicationPresenterOrderByRelationAggregateInput
  talk: ApplicationTalkOrderByWithRelationInput
  wantsCocktail: SortOrder
  wantsPanel: SortOrder
  workshop: ApplicationWorkshopOrderByWithRelationInput
}

enum CompanyApplicationScalarFieldEnum {
  booth
  cocktailId
  createdAt
  forCompanyId
  forSeasonId
  id
  updatedAt
  wantsCocktail
  wantsPanel
}

input CompanyApplicationWhereInput {
  AND: [CompanyApplicationWhereInput!]
  NOT: [CompanyApplicationWhereInput!]
  OR: [CompanyApplicationWhereInput!]
  approval: CompanyApplicationApprovalRelationFilter
  booth: StringNullableFilter
  cocktail: ApplicationCocktailRelationFilter
  forCompany: CompanyRelationFilter
  forSeason: SeasonRelationFilter
  panelParticipants: ApplicationPresenterListRelationFilter
  talk: ApplicationTalkRelationFilter
  wantsCocktail: BoolFilter
  wantsPanel: BoolFilter
  workshop: ApplicationWorkshopRelationFilter
}

input CompanyApplicationWhereUniqueInput {
  forCompanyId_forSeasonId: CompanyApplicationForCompanyIdForSeasonIdCompoundUniqueInput
}

type CompanyCount {
  applications: Int!
  members: Int!
}

input CompanyOrderByWithRelationInput {
  address: SortOrder
  brandName: SortOrder
  descriptionEn: SortOrder
  descriptionHr: SortOrder
  legalName: SortOrder
  vat: SortOrder
  website: SortOrder
}

type CompanyProgram {
  booth: String
  cocktail: ApplicationCocktail
  panel: CompanyProgramPanel
  talk: ApplicationTalk
  workshop: ApplicationWorkshop
}

type CompanyProgramPanel {
  companyPresenters: [ApplicationPresenter!]!
}

input CompanyRelationFilter {
  is: CompanyWhereInput
  isNot: CompanyWhereInput
}

enum CompanyScalarFieldEnum {
  address
  brandName
  createdAt
  descriptionEn
  descriptionHr
  id
  industryId
  legalName
  rasterLogoId
  uid
  updatedAt
  vat
  vectorLogoId
  website
}

input CompanyWhereInput {
  AND: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  address: StringFilter
  brandName: StringFilter
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  legalName: StringFilter
  vat: StringFilter
  website: StringFilter
}

input CompanyWhereUniqueInput {
  vat: String
}

type CreateCompanyApplicationResponse {
  entity: CompanyApplication
  errors: [FieldError!]
}

input CreateCompanyInput {
  address: String!
  brandName: String!
  descriptionEn: String!
  descriptionHr: String!
  industry: String = ""
  legalName: String!
  rasterLogo: Upload = null
  vat: String!
  vectorLogo: Upload = null
  website: String!
}

type CreateCompanyResponse {
  entity: Company
  errors: [FieldError!]
}

type CreatePartnerResponse {
  entity: Partner
  errors: [FieldError!]
}

type CreatePressReleaseResponse {
  entity: PressRelease
  errors: [FieldError!]
}

type CreateSponsorResponse {
  entity: Sponsor
  errors: [FieldError!]
}

# The javascript `Date` as string. Type represents date and time as the ISO Date string.
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

type EditApprovedCompanyApplicationResponse {
  entity: CompanyApplication
  errors: [FieldError!]
}

type FieldError {
  field: String!
  message: String!
}

type File {
  _count: FileCount
  createdAt: DateTime!
  etag: String!
  mimeType: String!
  name: String!
  size: Int!
  uid: String!
  updatedAt: DateTime!
}

type FileCount {
  forCompany: Int!
  forPressRelease: Int!
}

input FileOrderByWithRelationInput {
  etag: SortOrder
  mimeType: SortOrder
  name: SortOrder
  size: SortOrder
  uploader: UserOrderByWithRelationInput
}

input FileRelationFilter {
  is: FileWhereInput
  isNot: FileWhereInput
}

input FileWhereInput {
  AND: [FileWhereInput!]
  NOT: [FileWhereInput!]
  OR: [FileWhereInput!]
  etag: StringFilter
  mimeType: StringFilter
  name: StringFilter
  size: IntFilter
  uploader: UserRelationFilter
}

type Image {
  _count: ImageCount
  createdAt: DateTime!
  full: ImageVariation!
  fullUrl: String!
  name: String!
  thumb: ImageVariation!
  thumbUrl: String!
  uid: String!
  updatedAt: DateTime!
}

type ImageCount {
  ApplicationPresenter: Int!
  Company: Int!
  Partner: Int!
  Sponsor: Int!
}

input ImageRelationFilter {
  is: ImageWhereInput
  isNot: ImageWhereInput
}

type ImageVariation {
  _count: ImageVariationCount
  etag: String!
  mimeType: String!
}

type ImageVariationCount {
  forFull: Int!
  forOriginal: Int!
  forThumb: Int!
}

input ImageVariationRelationFilter {
  is: ImageVariationWhereInput
  isNot: ImageVariationWhereInput
}

input ImageVariationWhereInput {
  AND: [ImageVariationWhereInput!]
  NOT: [ImageVariationWhereInput!]
  OR: [ImageVariationWhereInput!]
  etag: StringFilter
  mimeType: StringFilter
}

input ImageWhereInput {
  AND: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  full: ImageVariationRelationFilter
  name: StringFilter
  original: ImageVariationRelationFilter
  thumb: ImageVariationRelationFilter
  uploader: UserRelationFilter
}

type Industry {
  _count: IndustryCount
  name: String!
}

type IndustryCount {
  company: Int!
}

input IndustryOrderByWithRelationInput {
  name: SortOrder
}

enum IndustryScalarFieldEnum {
  id
  name
}

input IndustryWhereInput {
  AND: [IndustryWhereInput!]
  NOT: [IndustryWhereInput!]
  OR: [IndustryWhereInput!]
  name: StringFilter
}

input IndustryWhereUniqueInput {
  name: String
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type Mutation {
  approveCompanyApplications(companies: [ApproveCompanyApplicationsInput!]!, season: String!): [CompanyApplicationApproval!]!
  createCompanyApplication(info: CompanyApplicationCreateInput!): CreateCompanyApplicationResponse
  createCompanyApplicationFor(company: String!, info: CompanyApplicationCreateInput!, season: String!): CreateCompanyApplicationResponse
  createIndustry(name: String!): Industry
  createPartner(info: PartnerCreateInput!, season: String!): CreatePartnerResponse!
  createPressRelease(info: PressReleaseWithFilesCreateInput!): CreatePressReleaseResponse
  createSeason(info: SeasonCreateInput!): Season
  createSponsor(info: SponsorCreateInput!, season: String!): CreateSponsorResponse!
  createTalkCategory(name: String!): ApplicationTalkCategory
  deletePartner(partner: String!): Boolean!
  deleteSeason(uid: String!): Season
  deleteSponsor(sponsor: String!): Boolean!
  editApprovedCompanyApplication(info: CompanyApplicationApprovedEditInput!): EditApprovedCompanyApplicationResponse
  login(identifier: String!, password: String!): AuthResponse!
  logout: Boolean!
  register(info: UserRegisterInput!): AuthResponse!
  registerCompany(info: CreateCompanyInput!): CreateCompanyResponse
  renameIndustry(newName: String!, oldName: String!): Industry
  renameTalkCategory(newName: String!, oldName: String!): ApplicationTalkCategory
  swapPartnerOrder(orderA: Int!, orderB: Int!, season: String!): Boolean!
  swapSponsorOrder(orderA: Int!, orderB: Int!, season: String!): Boolean!
  updateCompanyInfo(info: CreateCompanyInput!): CreateCompanyResponse
  updateCompanyMembersFor(company: String!, members: [String!]!): CreateCompanyResponse
  updatePassword(currentPassword: String!, newPassword: String!, newPasswordRepeat: String!): UpdatePasswordResponse
  updatePressRelease(info: PressReleaseWithFilesCreateInput!, uid: String!): CreatePressReleaseResponse
  updateProfile(info: UserCreateInput!): UpdateProfileResponse
  updateSeason(info: SeasonUpdateInput!): Season
  updateTranslation(data: TranslationCreateInput!): Translation
  updateUser(info: UserUpdateInput!, uid: String!): UpdateProfileResponse
  validateVat(vat: String!): ValidateVatResponse!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type News {
  content: String!
  date: DateTime!
  description: String!
  image: String!
  lang: String!
  slug: String!
  title: String!
}

type Partner {
  name: String!
  order: Int!
  photo: Image
  uid: String!
  url: String!
}

input PartnerCreateInput {
  name: String = ""
  photo: Upload = null
  url: String = ""
}

input PartnerListRelationFilter {
  every: PartnerWhereInput
  none: PartnerWhereInput
  some: PartnerWhereInput
}

input PartnerOrderByRelationAggregateInput {
  _count: SortOrder
}

input PartnerWhereInput {
  AND: [PartnerWhereInput!]
  NOT: [PartnerWhereInput!]
  OR: [PartnerWhereInput!]
  forSeason: SeasonRelationFilter
  name: StringFilter
  order: IntFilter
  photo: ImageRelationFilter
  url: StringFilter
}

input PresenterCreateInput {
  bioEn: String = ""
  bioHr: String = ""
  firstName: String = ""
  lastName: String = ""
  photo: Upload = null
}

type PressRelease {
  createdAt: DateTime!
  file: File
  published: DateTime!
  title: String!
  uid: String!
  updatedAt: DateTime!
}

input PressReleaseOrderByWithRelationInput {
  creator: UserOrderByWithRelationInput
  file: FileOrderByWithRelationInput
  published: SortOrder
  title: SortOrder
}

enum PressReleaseScalarFieldEnum {
  createdAt
  creatorId
  fileId
  id
  published
  title
  uid
  updatedAt
}

input PressReleaseWhereInput {
  AND: [PressReleaseWhereInput!]
  NOT: [PressReleaseWhereInput!]
  OR: [PressReleaseWhereInput!]
  creator: UserRelationFilter
  file: FileRelationFilter
  published: DateTimeFilter
  title: StringFilter
}

input PressReleaseWhereUniqueInput {
  uid: String = ""
}

input PressReleaseWithFilesCreateInput {
  file: Upload = null
  published: DateTime = null
  title: String = ""
}

type Query {
  allTranslationsFor(language: String!): [Translation!]!
  approvedCompanyApplications: [CompanyApplicationApproval!]!
  booths: [Booth!]!
  companies(cursor: CompanyWhereUniqueInput, distinct: [CompanyScalarFieldEnum!], orderBy: [CompanyOrderByWithRelationInput!], skip: Int, take: Int, where: CompanyWhereInput): [Company!]!
  company(vat: String!): Company
  companyApplication: CompanyApplication
  companyApplicationFor(company: String!, season: String!): CompanyApplication
  companyApplications(cursor: CompanyApplicationWhereUniqueInput, distinct: [CompanyApplicationScalarFieldEnum!], orderBy: [CompanyApplicationOrderByWithRelationInput!], season: String, skip: Int, take: Int, where: CompanyApplicationWhereInput): [CompanyApplication!]
  currentSeason: Season
  findFirstTranslation(cursor: TranslationWhereUniqueInput, distinct: [TranslationScalarFieldEnum!], orderBy: [TranslationOrderByWithRelationInput!], skip: Int, take: Int, where: TranslationWhereInput): Translation
  industries(cursor: IndustryWhereUniqueInput, distinct: [IndustryScalarFieldEnum!], orderBy: [IndustryOrderByWithRelationInput!], skip: Int, take: Int, where: IndustryWhereInput): [Industry!]!
  news(lang: String!): [News!]!
  newsItem(slug: String!): News
  participants(cursor: CompanyWhereUniqueInput, distinct: [CompanyScalarFieldEnum!], orderBy: [CompanyOrderByWithRelationInput!], skip: Int, take: Int, where: CompanyWhereInput): [Company!]!
  partners(season: String): [Partner!]!
  pressRelease(uid: String!): PressRelease
  pressReleases(cursor: PressReleaseWhereUniqueInput, distinct: [PressReleaseScalarFieldEnum!], orderBy: [PressReleaseOrderByWithRelationInput!], skip: Int, take: Int, where: PressReleaseWhereInput): [PressRelease!]!
  profile: User
  roles(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): [Role!]!
  season(uid: String!): Season
  seasons(cursor: SeasonWhereUniqueInput, distinct: [SeasonScalarFieldEnum!], orderBy: [SeasonOrderByWithRelationInput!], skip: Int, take: Int, where: SeasonWhereInput): [Season!]!
  sponsors(season: String): [Sponsor!]!
  talkCategories(cursor: ApplicationTalkCategoryWhereUniqueInput, distinct: [ApplicationTalkCategoryScalarFieldEnum!], orderBy: [ApplicationTalkCategoryOrderByWithRelationInput!], skip: Int, take: Int, where: ApplicationTalkCategoryWhereInput): [ApplicationTalkCategory!]!
  translation(where: TranslationWhereUniqueInput!): Translation
  translations(cursor: TranslationWhereUniqueInput, distinct: [TranslationScalarFieldEnum!], orderBy: [TranslationOrderByWithRelationInput!], skip: Int, take: Int, where: TranslationWhereInput): [Translation!]!
  user(uid: String!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type Role {
  _count: RoleCount
  createdAt: DateTime!
  name: String!
  updatedAt: DateTime!
}

type RoleCount {
  users: Int!
}

input RoleOrderByWithRelationInput {
  name: SortOrder
}

enum RoleScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  name: StringFilter
}

input RoleWhereUniqueInput {
  name: String
}

type Season {
  _count: SeasonCount
  applications: [CompanyApplication!]!
  applicationsFrom: DateTime!
  applicationsUntil: DateTime!
  endsAt: DateTime!
  name: String!
  showParticipantsFrom: DateTime!
  showParticipantsUntil: DateTime!
  showPartnersFrom: DateTime!
  showPartnersUntil: DateTime!
  showSponsorsFrom: DateTime!
  showSponsorsUntil: DateTime!
  startsAt: DateTime!
  uid: String!
}

type SeasonCount {
  companies: Int!
  partners: Int!
  sponsors: Int!
}

input SeasonCreateInput {
  applicationsFrom: DateTime = null
  applicationsUntil: DateTime = null
  endsAt: DateTime = null
  name: String = ""
  showParticipantsFrom: DateTime = null
  showParticipantsUntil: DateTime = null
  showPartnersFrom: DateTime = null
  showPartnersUntil: DateTime = null
  showSponsorsFrom: DateTime = null
  showSponsorsUntil: DateTime = null
  startsAt: DateTime = null
}

input SeasonOrderByWithRelationInput {
  applicationsFrom: SortOrder
  applicationsUntil: SortOrder
  companies: CompanyApplicationOrderByRelationAggregateInput
  endsAt: SortOrder
  name: SortOrder
  partners: PartnerOrderByRelationAggregateInput
  showParticipantsFrom: SortOrder
  showParticipantsUntil: SortOrder
  showPartnersFrom: SortOrder
  showPartnersUntil: SortOrder
  showSponsorsFrom: SortOrder
  showSponsorsUntil: SortOrder
  sponsors: SponsorOrderByRelationAggregateInput
  startsAt: SortOrder
  uid: SortOrder
}

input SeasonRelationFilter {
  is: SeasonWhereInput
  isNot: SeasonWhereInput
}

enum SeasonScalarFieldEnum {
  applicationsFrom
  applicationsUntil
  endsAt
  id
  name
  showParticipantsFrom
  showParticipantsUntil
  showPartnersFrom
  showPartnersUntil
  showSponsorsFrom
  showSponsorsUntil
  startsAt
  uid
}

input SeasonUpdateInput {
  applicationsFrom: DateTime = null
  applicationsUntil: DateTime = null
  endsAt: DateTime = null
  name: String = ""
  showParticipantsFrom: DateTime = null
  showParticipantsUntil: DateTime = null
  showPartnersFrom: DateTime = null
  showPartnersUntil: DateTime = null
  showSponsorsFrom: DateTime = null
  showSponsorsUntil: DateTime = null
  startsAt: DateTime = null
  uid: String = ""
}

input SeasonWhereInput {
  AND: [SeasonWhereInput!]
  NOT: [SeasonWhereInput!]
  OR: [SeasonWhereInput!]
  applicationsFrom: DateTimeFilter
  applicationsUntil: DateTimeFilter
  companies: CompanyApplicationListRelationFilter
  endsAt: DateTimeFilter
  name: StringFilter
  partners: PartnerListRelationFilter
  showParticipantsFrom: DateTimeFilter
  showParticipantsUntil: DateTimeFilter
  showPartnersFrom: DateTimeFilter
  showPartnersUntil: DateTimeFilter
  showSponsorsFrom: DateTimeFilter
  showSponsorsUntil: DateTimeFilter
  sponsors: SponsorListRelationFilter
  startsAt: DateTimeFilter
  uid: StringFilter
}

input SeasonWhereUniqueInput {
  uid: String
}

enum SortOrder {
  asc
  desc
}

type Sponsor {
  name: String!
  order: Int!
  photo: Image
  uid: String!
  url: String!
}

input SponsorCreateInput {
  name: String = ""
  photo: Upload = null
  url: String = ""
}

input SponsorListRelationFilter {
  every: SponsorWhereInput
  none: SponsorWhereInput
  some: SponsorWhereInput
}

input SponsorOrderByRelationAggregateInput {
  _count: SortOrder
}

input SponsorWhereInput {
  AND: [SponsorWhereInput!]
  NOT: [SponsorWhereInput!]
  OR: [SponsorWhereInput!]
  forSeason: SeasonRelationFilter
  name: StringFilter
  order: IntFilter
  photo: ImageRelationFilter
  url: StringFilter
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input TalkCreateInput {
  category: String = ""
  descriptionEn: String = ""
  descriptionHr: String = ""
  language: String = ""
  presenter: PresenterCreateInput = null
  titleEn: String = ""
  titleHr: String = ""
}

input TalksCreateInput {
  category: String = ""
  descriptionEn: String = ""
  descriptionHr: String = ""
  language: String = ""
  presenter: [PresenterCreateInput!] = []
  titleEn: String = ""
  titleHr: String = ""
}

type Translation {
  createdAt: DateTime!
  key: String!
  language: String!
  updatedAt: DateTime!
  value: String!
}

input TranslationCreateInput {
  key: String!
  language: String!
  value: String!
}

input TranslationKeyLanguageCompoundUniqueInput {
  key: String!
  language: String!
}

input TranslationOrderByWithRelationInput {
  key: SortOrder
  language: SortOrder
  value: SortOrder
}

enum TranslationScalarFieldEnum {
  createdAt
  key
  language
  updatedAt
  value
}

input TranslationWhereInput {
  AND: [TranslationWhereInput!]
  NOT: [TranslationWhereInput!]
  OR: [TranslationWhereInput!]
  key: StringFilter
  language: StringFilter
  value: StringFilter
}

input TranslationWhereUniqueInput {
  key_language: TranslationKeyLanguageCompoundUniqueInput
}

type UpdatePasswordResponse {
  entity: User
  errors: [FieldError!]
}

type UpdateProfileResponse {
  entity: User
  errors: [FieldError!]
}

# The `Upload` scalar type represents a file upload.
scalar Upload

type User {
  _count: UserCount
  companies: [Company!]!
  createdAt: DateTime!
  email: String!
  firstName: String!
  lastName: String!
  name: String!
  phone: String!
  roles: [Role!]!
  uid: String!
  updatedAt: DateTime!
}

type UserCount {
  companies: Int!
  events: Int!
  files: Int!
  images: Int!
  pressReleases: Int!
  roles: Int!
}

input UserCreateInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  phone: String!
}

input UserOrderByWithRelationInput {
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
}

input UserRegisterInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  passwordRepeat: String = ""
  phone: String!
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  firstName
  id
  lastName
  password
  phone
  uid
  updatedAt
}

input UserUpdateInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  phone: String!
  roles: [String!] = []
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  email: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
}

input UserWhereUniqueInput {
  email: String
}

type ValidateVatResponse {
  exists: Boolean!
  info: VatData
  valid: Boolean!
}

type VatData {
  address: String!
  legalName: String!
}

input WorkshopCreateInput {
  descriptionEn: String = ""
  descriptionHr: String = ""
  goal: String = ""
  language: String = ""
  notesEn: String = ""
  notesHr: String = ""
  presenter: PresenterCreateInput = null
  titleEn: String = ""
  titleHr: String = ""
}

input WorkshopsCreateInput {
  descriptionEn: String = ""
  descriptionHr: String = ""
  goal: String = ""
  language: String = ""
  notesEn: String = ""
  notesHr: String = ""
  presenter: [PresenterCreateInput!] = []
  titleEn: String = ""
  titleHr: String = ""
}

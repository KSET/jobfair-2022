# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AuthResponse {
  entity: User
  errors: [FieldError!]
}

type Company {
  _count: CompanyCount
  address: String!
  brandName: String!
  descriptionEn: String!
  descriptionHr: String!
  industry: Industry
  legalName: String!
  members: [User!]!
  uid: String!
  vat: String!
  website: String!
}

type CompanyCount {
  usersCompanies: Int!
}

input CompanyOrderByWithRelationInput {
  address: SortOrder
  brandName: SortOrder
  descriptionEn: SortOrder
  descriptionHr: SortOrder
  legalName: SortOrder
  vat: SortOrder
  website: SortOrder
}

enum CompanyScalarFieldEnum {
  address
  brandName
  descriptionEn
  descriptionHr
  id
  industryId
  legalName
  uid
  vat
  website
}

input CompanyWhereInput {
  AND: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  address: StringFilter
  brandName: StringFilter
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  legalName: StringFilter
  vat: StringFilter
  website: StringFilter
}

input CompanyWhereUniqueInput {
  vat: String
}

input CreateCompanyInput {
  address: String!
  brandName: String!
  descriptionEn: String!
  descriptionHr: String!
  industry: String = ""
  legalName: String!
  vat: String!
  website: String!
}

type CreateCompanyResponse {
  entity: Company
  errors: [FieldError!]
}

# The javascript `Date` as string. Type represents date and time as the ISO Date string.
scalar DateTime

type FieldError {
  field: String!
  message: String!
}

type Industry {
  _count: IndustryCount
  name: String!
}

type IndustryCount {
  company: Int!
}

input IndustryOrderByWithRelationInput {
  name: SortOrder
}

enum IndustryScalarFieldEnum {
  id
  name
}

input IndustryWhereInput {
  AND: [IndustryWhereInput!]
  NOT: [IndustryWhereInput!]
  OR: [IndustryWhereInput!]
  name: StringFilter
}

input IndustryWhereUniqueInput {
  name: String
}

type Mutation {
  createIndustry(name: String!): Industry
  login(identifier: String!, password: String!): AuthResponse!
  logout: Boolean!
  register(info: UserRegisterInput!): AuthResponse!
  registerCompany(info: CreateCompanyInput!): CreateCompanyResponse
  renameIndustry(newName: String!, oldName: String!): Industry
  updateCompanyInfo(info: CreateCompanyInput!): CreateCompanyResponse
  updatePassword(currentPassword: String!, newPassword: String!, newPasswordRepeat: String!): UpdatePasswordResponse
  updateProfile(info: UserCreateInput!): UpdateProfileResponse
  updateTranslation(data: TranslationCreateInput!): Translation
  validateVat(vat: String!): ValidateVatResponse!
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  allTranslationsFor(language: String!): [Translation!]!
  companies(cursor: CompanyWhereUniqueInput, distinct: [CompanyScalarFieldEnum!], orderBy: [CompanyOrderByWithRelationInput!], skip: Int, take: Int, where: CompanyWhereInput): [Company!]!
  company(vat: String!): Company
  findFirstTranslation(cursor: TranslationWhereUniqueInput, distinct: [TranslationScalarFieldEnum!], orderBy: [TranslationOrderByWithRelationInput!], skip: Int, take: Int, where: TranslationWhereInput): Translation
  industries(cursor: IndustryWhereUniqueInput, distinct: [IndustryScalarFieldEnum!], orderBy: [IndustryOrderByWithRelationInput!], skip: Int, take: Int, where: IndustryWhereInput): [Industry!]!
  profile: User
  translation(where: TranslationWhereUniqueInput!): Translation
  translations(cursor: TranslationWhereUniqueInput, distinct: [TranslationScalarFieldEnum!], orderBy: [TranslationOrderByWithRelationInput!], skip: Int, take: Int, where: TranslationWhereInput): [Translation!]!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type Role {
  _count: RoleCount
  createdAt: DateTime!
  name: String!
  updatedAt: DateTime!
}

type RoleCount {
  usersRoles: Int!
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Translation {
  createdAt: DateTime!
  key: String!
  language: String!
  updatedAt: DateTime!
  value: String!
}

input TranslationCreateInput {
  key: String!
  language: String!
  value: String!
}

input TranslationKeyLanguageCompoundUniqueInput {
  key: String!
  language: String!
}

input TranslationOrderByWithRelationInput {
  key: SortOrder
  language: SortOrder
  value: SortOrder
}

enum TranslationScalarFieldEnum {
  createdAt
  key
  language
  updatedAt
  value
}

input TranslationWhereInput {
  AND: [TranslationWhereInput!]
  NOT: [TranslationWhereInput!]
  OR: [TranslationWhereInput!]
  key: StringFilter
  language: StringFilter
  value: StringFilter
}

input TranslationWhereUniqueInput {
  key_language: TranslationKeyLanguageCompoundUniqueInput
}

type UpdatePasswordResponse {
  entity: User
  errors: [FieldError!]
}

type UpdateProfileResponse {
  entity: User
  errors: [FieldError!]
}

type User {
  _count: UserCount
  companies: [Company!]!
  createdAt: DateTime!
  email: String!
  firstName: String!
  lastName: String!
  name: String!
  phone: String!
  roles: [Role!]!
  uid: String!
  updatedAt: DateTime!
}

type UserCount {
  events: Int!
  usersCompanies: Int!
  usersRoles: Int!
}

input UserCreateInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  phone: String!
}

input UserOrderByWithRelationInput {
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
}

input UserRegisterInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  passwordRepeat: String = ""
  phone: String!
}

enum UserScalarFieldEnum {
  createdAt
  email
  firstName
  id
  lastName
  password
  phone
  uid
  updatedAt
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  email: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
}

input UserWhereUniqueInput {
  email: String
}

type ValidateVatResponse {
  exists: Boolean!
  info: VatData
  valid: Boolean!
}

type VatData {
  address: String!
  legalName: String!
}

# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type ApplicationCocktail {
  _count: ApplicationCocktailCount
  colour: String!
  forApplication: [CompanyApplication!]!
  name: String!
}

type ApplicationCocktailCount {
  forApplication: Int!
}

enum ApplicationCocktailOrderByRelevanceFieldEnum {
  colour
  name
}

input ApplicationCocktailOrderByRelevanceInput {
  fields: [ApplicationCocktailOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input ApplicationCocktailOrderByWithRelationAndSearchRelevanceInput {
  _relevance: ApplicationCocktailOrderByRelevanceInput
  colour: SortOrder
  name: SortOrder
}

input ApplicationCocktailRelationFilter {
  is: ApplicationCocktailWhereInput
  isNot: ApplicationCocktailWhereInput
}

input ApplicationCocktailWhereInput {
  AND: [ApplicationCocktailWhereInput!]
  NOT: [ApplicationCocktailWhereInput!]
  OR: [ApplicationCocktailWhereInput!]
  colour: StringFilter
  name: StringFilter
}

type ApplicationPresenter {
  _count: ApplicationPresenterCount
  bioEn: String!
  bioHr: String!
  createdAt: DateTimeISO!
  firstName: String!
  lastName: String!
  photo: Image
  updatedAt: DateTimeISO!
}

type ApplicationPresenterCount {
  forPanels: Int!
  forTalks: Int!
  forWorkshops: Int!
}

input ApplicationPresenterListRelationFilter {
  every: ApplicationPresenterWhereInput
  none: ApplicationPresenterWhereInput
  some: ApplicationPresenterWhereInput
}

input ApplicationPresenterOrderByRelationAggregateInput {
  _count: SortOrder
}

input ApplicationPresenterWhereInput {
  AND: [ApplicationPresenterWhereInput!]
  NOT: [ApplicationPresenterWhereInput!]
  OR: [ApplicationPresenterWhereInput!]
  bioEn: StringFilter
  bioHr: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  photo: ImageRelationFilter
}

type ApplicationTalk {
  _count: ApplicationTalkCount
  category: ApplicationTalkCategory!
  createdAt: DateTimeISO!
  descriptionEn: String!
  descriptionHr: String!
  event: CalendarItem
  language: String!
  presenters: [ApplicationPresenter!]!
  reservation: Float!
  titleEn: String!
  titleHr: String!
  uid: String!
  updatedAt: DateTimeISO!
}

type ApplicationTalkCategory {
  _count: ApplicationTalkCategoryCount
  forSeason: Season
  name: String!
}

type ApplicationTalkCategoryCount {
  talks: Int!
}

input ApplicationTalkCategoryForSeasonIdNameCompoundUniqueInput {
  forSeasonId: Int!
  name: String!
}

enum ApplicationTalkCategoryOrderByRelevanceFieldEnum {
  name
}

input ApplicationTalkCategoryOrderByRelevanceInput {
  fields: [ApplicationTalkCategoryOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input ApplicationTalkCategoryOrderByWithRelationAndSearchRelevanceInput {
  _relevance: ApplicationTalkCategoryOrderByRelevanceInput
  forSeason: SeasonOrderByWithRelationAndSearchRelevanceInput
  name: SortOrder
}

input ApplicationTalkCategoryRelationFilter {
  is: ApplicationTalkCategoryWhereInput
  isNot: ApplicationTalkCategoryWhereInput
}

enum ApplicationTalkCategoryScalarFieldEnum {
  forSeasonId
  id
  name
}

input ApplicationTalkCategoryWhereInput {
  AND: [ApplicationTalkCategoryWhereInput!]
  NOT: [ApplicationTalkCategoryWhereInput!]
  OR: [ApplicationTalkCategoryWhereInput!]
  forSeason: SeasonRelationFilter
  name: StringFilter
}

input ApplicationTalkCategoryWhereUniqueInput {
  forSeasonId_name: ApplicationTalkCategoryForSeasonIdNameCompoundUniqueInput
}

type ApplicationTalkCount {
  presenters: Int!
}

enum ApplicationTalkOrderByRelevanceFieldEnum {
  descriptionEn
  descriptionHr
  language
  titleEn
  titleHr
  uid
}

input ApplicationTalkOrderByRelevanceInput {
  fields: [ApplicationTalkOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input ApplicationTalkOrderByWithRelationAndSearchRelevanceInput {
  _relevance: ApplicationTalkOrderByRelevanceInput
  category: ApplicationTalkCategoryOrderByWithRelationAndSearchRelevanceInput
  descriptionEn: SortOrder
  descriptionHr: SortOrder
  event: CalendarItemOrderByWithRelationAndSearchRelevanceInput
  language: SortOrder
  titleEn: SortOrder
  titleHr: SortOrder
}

input ApplicationTalkRelationFilter {
  is: ApplicationTalkWhereInput
  isNot: ApplicationTalkWhereInput
}

input ApplicationTalkWhereInput {
  AND: [ApplicationTalkWhereInput!]
  NOT: [ApplicationTalkWhereInput!]
  OR: [ApplicationTalkWhereInput!]
  category: ApplicationTalkCategoryRelationFilter
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  event: CalendarItemRelationFilter
  language: StringFilter
  titleEn: StringFilter
  titleHr: StringFilter
}

type ApplicationWorkshop {
  _count: ApplicationWorkshopCount
  createdAt: DateTimeISO!
  descriptionEn: String!
  descriptionHr: String!
  event: CalendarItem
  goal: String!
  language: String!
  notesEn: String!
  notesHr: String!
  presenters: [ApplicationPresenter!]!
  reservation: Float!
  titleEn: String!
  titleHr: String!
  uid: String!
  updatedAt: DateTimeISO!
}

type ApplicationWorkshopCount {
  presenters: Int!
}

enum ApplicationWorkshopOrderByRelevanceFieldEnum {
  descriptionEn
  descriptionHr
  goal
  language
  notesEn
  notesHr
  titleEn
  titleHr
  uid
}

input ApplicationWorkshopOrderByRelevanceInput {
  fields: [ApplicationWorkshopOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input ApplicationWorkshopOrderByWithRelationAndSearchRelevanceInput {
  _relevance: ApplicationWorkshopOrderByRelevanceInput
  descriptionEn: SortOrder
  descriptionHr: SortOrder
  event: CalendarItemOrderByWithRelationAndSearchRelevanceInput
  goal: SortOrder
  language: SortOrder
  notesEn: SortOrder
  notesHr: SortOrder
  titleEn: SortOrder
  titleHr: SortOrder
}

input ApplicationWorkshopRelationFilter {
  is: ApplicationWorkshopWhereInput
  isNot: ApplicationWorkshopWhereInput
}

input ApplicationWorkshopWhereInput {
  AND: [ApplicationWorkshopWhereInput!]
  NOT: [ApplicationWorkshopWhereInput!]
  OR: [ApplicationWorkshopWhereInput!]
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  event: CalendarItemRelationFilter
  goal: StringFilter
  language: StringFilter
  notesEn: StringFilter
  notesHr: StringFilter
  titleEn: StringFilter
  titleHr: StringFilter
}

input ApproveCompanyApplicationsInput {
  parts: ApproveCompanyApplicationsInputParts!
  uid: String!
}

input ApproveCompanyApplicationsInputParts {
  booth: Boolean!
  cocktail: Boolean!
  logoHidden: Boolean!
  panel: Boolean!
  talkParticipants: Float!
  workshopParticipants: Float!
}

type AuthResponse {
  entity: User
  errors: [FieldError!]
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Booth {
  key: String
  name: String!
}

type CalendarEvent {
  class: String!
  end: DateTimeISO!
  location: String!
  noGroup: Boolean!
  start: DateTimeISO!
  text: String!
  title: String!
}

input CalendarFilterInput {
  type: String
}

type CalendarItem {
  capacity: Int!
  companies: [Company!]
  end: DateTimeISO!
  forPanel: CompanyPanel
  forTalk: ApplicationTalk
  forWorkshop: ApplicationWorkshop
  grouped: Boolean!
  hasEvent: Boolean!
  location: String
  start: DateTimeISO!
  text: String
  title: String
  type: String
  uid: String!
}

input CalendarItemListRelationFilter {
  every: CalendarItemWhereInput
  none: CalendarItemWhereInput
  some: CalendarItemWhereInput
}

input CalendarItemOrderByRelationAggregateInput {
  _count: SortOrder
}

enum CalendarItemOrderByRelevanceFieldEnum {
  location
  text
  title
  type
  uid
}

input CalendarItemOrderByRelevanceInput {
  fields: [CalendarItemOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input CalendarItemOrderByWithRelationAndSearchRelevanceInput {
  _relevance: CalendarItemOrderByRelevanceInput
  end: SortOrder
  forSeason: SeasonOrderByWithRelationAndSearchRelevanceInput
  grouped: SortOrder
  location: SortOrder
  start: SortOrder
  text: SortOrder
  title: SortOrder
  type: SortOrder
}

input CalendarItemRelationFilter {
  is: CalendarItemWhereInput
  isNot: CalendarItemWhereInput
}

input CalendarItemWhereInput {
  AND: [CalendarItemWhereInput!]
  NOT: [CalendarItemWhereInput!]
  OR: [CalendarItemWhereInput!]
  end: DateTimeFilter
  forSeason: SeasonRelationFilter
  grouped: BoolFilter
  location: StringNullableFilter
  start: DateTimeFilter
  text: StringNullableFilter
  title: StringNullableFilter
  type: StringNullableFilter
}

input CalendarUpdateInput {
  end: DateTimeISO!
  forUid: String
  grouped: Boolean
  location: String
  season: String!
  start: DateTimeISO!
  text: String
  title: String
  type: String
  uid: String
}

input CocktailCreateInput {
  colour: String!
  name: String!
}

type Company {
  _count: CompanyCount
  address: String!
  brandName: String!
  createdAt: DateTimeISO!
  descriptionEn: String!
  descriptionHr: String!
  industry: Industry
  legalName: String!
  logoHidden: Boolean!
  members: [User!]
  program: CompanyProgram
  rasterLogo: Image
  uid: String!
  updatedAt: DateTimeISO!
  vat: String!
  vectorLogo: File
  website: String!
}

type CompanyApplication {
  _count: CompanyApplicationCount
  approval: CompanyApplicationApproval
  booth: String
  cocktail: ApplicationCocktail
  createdAt: DateTimeISO!
  feedback: CompanyApplicationFeedback
  forCompany: Company
  forSeason: Season
  panelParticipants: [ApplicationPresenter!]!
  talk: ApplicationTalk
  updatedAt: DateTimeISO!
  userApplications: EventUserApplications!
  wantsCocktail: Boolean!
  wantsPanel: Boolean!
  workshop: ApplicationWorkshop
}

type CompanyApplicationApproval {
  booth: Boolean!
  cocktail: Boolean!
  forApplication: CompanyApplication!
  logoHidden: Boolean!
  panel: Boolean!
  talkParticipants: Int!
  workshopParticipants: Int!
}

input CompanyApplicationApprovalOrderByWithRelationAndSearchRelevanceInput {
  booth: SortOrder
  cocktail: SortOrder
  logoHidden: SortOrder
  panel: SortOrder
  talkParticipants: SortOrder
  workshopParticipants: SortOrder
}

input CompanyApplicationApprovalRelationFilter {
  is: CompanyApplicationApprovalWhereInput
  isNot: CompanyApplicationApprovalWhereInput
}

input CompanyApplicationApprovalWhereInput {
  AND: [CompanyApplicationApprovalWhereInput!]
  NOT: [CompanyApplicationApprovalWhereInput!]
  OR: [CompanyApplicationApprovalWhereInput!]
  booth: BoolFilter
  cocktail: BoolFilter
  logoHidden: BoolFilter
  panel: BoolFilter
  talkParticipants: IntFilter
  workshopParticipants: IntFilter
}

input CompanyApplicationApprovedEditInput {
  cocktail: CocktailCreateInput
  panel: [PresenterCreateInput!]!
  talk: TalksCreateInput
  vat: String!
  workshop: WorkshopsCreateInput
}

type CompanyApplicationCount {
  panelParticipants: Int!
}

input CompanyApplicationCreateInput {
  booth: String
  talk: TalkCreateInput
  vat: String!
  wantsCocktail: Boolean!
  wantsPanel: Boolean!
  workshop: WorkshopCreateInput
}

type CompanyApplicationFeedback {
  applicationComments: String!
  applicationRating: Int!
  attendanceRating: Int!
  createdAt: DateTimeISO!
  dateComments: String!
  dateRating: Int!
  experienceComments: String!
  foodRating: Int!
  mostLiked: Int!
  onsiteRating: Int!
  overallComment: String!
  overallRating: Int!
  recommended: Int!
  testimonial: String!
  timeRating: Int!
  updatedAt: DateTimeISO!
}

input CompanyApplicationFeedbackCreateInput {
  applicationComments: String
  applicationRating: Int!
  attendanceRating: Int!
  dateComments: String
  dateRating: Int!
  experienceComments: String
  foodRating: Int!
  mostLiked: Int!
  onsiteRating: Int!
  overallComment: String
  overallRating: Int!
  recommended: Int!
  testimonial: String
  timeRating: Int!
}

input CompanyApplicationForCompanyIdForSeasonIdCompoundUniqueInput {
  forCompanyId: Int!
  forSeasonId: Int!
}

input CompanyApplicationListRelationFilter {
  every: CompanyApplicationWhereInput
  none: CompanyApplicationWhereInput
  some: CompanyApplicationWhereInput
}

input CompanyApplicationOrderByRelationAggregateInput {
  _count: SortOrder
}

enum CompanyApplicationOrderByRelevanceFieldEnum {
  booth
}

input CompanyApplicationOrderByRelevanceInput {
  fields: [CompanyApplicationOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input CompanyApplicationOrderByWithRelationAndSearchRelevanceInput {
  _relevance: CompanyApplicationOrderByRelevanceInput
  approval: CompanyApplicationApprovalOrderByWithRelationAndSearchRelevanceInput
  booth: SortOrder
  cocktail: ApplicationCocktailOrderByWithRelationAndSearchRelevanceInput
  forCompany: CompanyOrderByWithRelationAndSearchRelevanceInput
  forSeason: SeasonOrderByWithRelationAndSearchRelevanceInput
  panel: CompanyPanelOrderByWithRelationAndSearchRelevanceInput
  panelParticipants: ApplicationPresenterOrderByRelationAggregateInput
  talk: ApplicationTalkOrderByWithRelationAndSearchRelevanceInput
  wantsCocktail: SortOrder
  wantsPanel: SortOrder
  workshop: ApplicationWorkshopOrderByWithRelationAndSearchRelevanceInput
}

enum CompanyApplicationScalarFieldEnum {
  booth
  cocktailId
  createdAt
  feedbackFormId
  forCompanyId
  forSeasonId
  id
  panelId
  updatedAt
  wantsCocktail
  wantsPanel
}

input CompanyApplicationWhereInput {
  AND: [CompanyApplicationWhereInput!]
  NOT: [CompanyApplicationWhereInput!]
  OR: [CompanyApplicationWhereInput!]
  approval: CompanyApplicationApprovalRelationFilter
  booth: StringNullableFilter
  cocktail: ApplicationCocktailRelationFilter
  forCompany: CompanyRelationFilter
  forSeason: SeasonRelationFilter
  panel: CompanyPanelRelationFilter
  panelParticipants: ApplicationPresenterListRelationFilter
  talk: ApplicationTalkRelationFilter
  wantsCocktail: BoolFilter
  wantsPanel: BoolFilter
  workshop: ApplicationWorkshopRelationFilter
}

input CompanyApplicationWhereUniqueInput {
  forCompanyId_forSeasonId: CompanyApplicationForCompanyIdForSeasonIdCompoundUniqueInput
}

type CompanyCount {
  applications: Int!
  favouriteResumes: Int!
  members: Int!
  scannedResumes: Int!
  scannedUsers: Int!
}

enum CompanyOrderByRelevanceFieldEnum {
  address
  brandName
  descriptionEn
  descriptionHr
  legalName
  uid
  vat
  website
}

input CompanyOrderByRelevanceInput {
  fields: [CompanyOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input CompanyOrderByWithRelationAndSearchRelevanceInput {
  _relevance: CompanyOrderByRelevanceInput
  address: SortOrder
  brandName: SortOrder
  descriptionEn: SortOrder
  descriptionHr: SortOrder
  legalName: SortOrder
  vat: SortOrder
  website: SortOrder
}

type CompanyPanel {
  _count: CompanyPanelCount
  companies: [Company!]!
  description: String!
  event: CalendarItem
  name: String!
  reservation: Float!
  uid: String!
}

type CompanyPanelCount {
  companies: Int!
}

enum CompanyPanelOrderByRelevanceFieldEnum {
  description
  name
  uid
}

input CompanyPanelOrderByRelevanceInput {
  fields: [CompanyPanelOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input CompanyPanelOrderByWithRelationAndSearchRelevanceInput {
  _relevance: CompanyPanelOrderByRelevanceInput
  companies: CompanyApplicationOrderByRelationAggregateInput
  description: SortOrder
  event: CalendarItemOrderByWithRelationAndSearchRelevanceInput
  name: SortOrder
}

input CompanyPanelRelationFilter {
  is: CompanyPanelWhereInput
  isNot: CompanyPanelWhereInput
}

input CompanyPanelUpdateInput {
  companies: [String!]!
  description: String!
  name: String!
  season: String!
  uid: String
}

input CompanyPanelWhereInput {
  AND: [CompanyPanelWhereInput!]
  NOT: [CompanyPanelWhereInput!]
  OR: [CompanyPanelWhereInput!]
  companies: CompanyApplicationListRelationFilter
  description: StringFilter
  event: CalendarItemRelationFilter
  name: StringFilter
}

type CompanyProgram {
  booth: String
  cocktail: ApplicationCocktail
  panel: CompanyPanel
  panelParticipants: [ApplicationPresenter!]!
  talk: ApplicationTalk
  workshop: ApplicationWorkshop
}

input CompanyRelationFilter {
  is: CompanyWhereInput
  isNot: CompanyWhereInput
}

enum CompanyScalarFieldEnum {
  address
  brandName
  createdAt
  descriptionEn
  descriptionHr
  id
  industryId
  legalName
  rasterLogoId
  uid
  updatedAt
  vat
  vectorLogoId
  website
}

input CompanyScanUserQrRefineData {
  isStarred: Boolean
  note: String
}

type CompanyScanUserQrResponse {
  alreadyScanned: Boolean!
  error: String
  isStarred: Boolean
  note: String
  user: User
}

type CompanyScannedUser {
  isStarred: Boolean!
  note: String
  scannedAt: DateTimeISO!
  user: User
}

input CompanyScannedUserListRelationFilter {
  every: CompanyScannedUserWhereInput
  none: CompanyScannedUserWhereInput
  some: CompanyScannedUserWhereInput
}

input CompanyScannedUserOrderByRelationAggregateInput {
  _count: SortOrder
}

input CompanyScannedUserWhereInput {
  AND: [CompanyScannedUserWhereInput!]
  NOT: [CompanyScannedUserWhereInput!]
  OR: [CompanyScannedUserWhereInput!]
  isStarred: BoolFilter
  note: StringNullableFilter
  scannedAt: DateTimeFilter
}

input CompanyWhereInput {
  AND: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  address: StringFilter
  brandName: StringFilter
  descriptionEn: StringFilter
  descriptionHr: StringFilter
  legalName: StringFilter
  vat: StringFilter
  website: StringFilter
}

input CompanyWhereUniqueInput {
  vat: String
}

type CreateCompanyApplicationResponse {
  entity: CompanyApplication
  errors: [FieldError!]
}

input CreateCompanyInput {
  address: String!
  brandName: String!
  descriptionEn: String!
  descriptionHr: String!
  industry: String!
  legalName: String!
  rasterLogo: Upload
  vat: String!
  vectorLogo: Upload
  website: String!
}

type CreateCompanyResponse {
  entity: Company
  errors: [FieldError!]
}

type CreatePartnerResponse {
  entity: Partner
  errors: [FieldError!]
}

type CreatePressReleaseResponse {
  entity: PressRelease
  errors: [FieldError!]
}

type CreateSponsorResponse {
  entity: Sponsor
  errors: [FieldError!]
}

input DateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

input DateTimeNullableFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableFilter
  notIn: [DateTimeISO!]
}

type EditApprovedCompanyApplicationResponse {
  entity: CompanyApplication
  errors: [FieldError!]
}

type EventLog {
  data: String
  date: DateTimeISO!
  id: Int!
  name: String!
  user: User
}

enum EventLogOrderByRelevanceFieldEnum {
  data
  name
}

input EventLogOrderByRelevanceInput {
  fields: [EventLogOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input EventLogOrderByWithRelationAndSearchRelevanceInput {
  _relevance: EventLogOrderByRelevanceInput
  data: SortOrder
  date: String
  id: String
  name: SortOrder
  user: UserOrderByWithRelationAndSearchRelevanceInput
}

type EventLogPaginationResult {
  page: Int!
  perPage: Int!
  records: [EventLog!]!
  totalRecords: Int!
}

input EventReservationCreateManyUserInput {
  eventId: Int!
  eventType: String!
  status: Int!
}

input EventReservationCreateManyUserInputEnvelope {
  data: [EventReservationCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input EventReservationCreateNestedManyWithoutUserInput {
  connect: [EventReservationWhereUniqueInput!]
  connectOrCreate: [EventReservationCreateOrConnectWithoutUserInput!]
  create: [EventReservationCreateWithoutUserInput!]
  createMany: EventReservationCreateManyUserInputEnvelope
}

input EventReservationCreateOrConnectWithoutUserInput {
  create: EventReservationCreateWithoutUserInput!
  where: EventReservationWhereUniqueInput!
}

input EventReservationCreateWithoutUserInput {
  eventId: Int!
  eventType: String!
  status: Int!
}

input EventReservationEventIdEventTypeUserIdCompoundUniqueInput {
  eventId: Int!
  eventType: String!
  userId: Int!
}

input EventReservationListRelationFilter {
  every: EventReservationWhereInput
  none: EventReservationWhereInput
  some: EventReservationWhereInput
}

input EventReservationOrderByRelationAggregateInput {
  _count: SortOrder
}

type EventReservationResponse {
  entity: EventReservationStatus
  errors: [FieldError!]
}

type EventReservationStatus {
  status: Int!
}

input EventReservationUpdateInput {
  id: String!
  status: Int!
  type: EventType!
}

input EventReservationWhereInput {
  AND: [EventReservationWhereInput!]
  NOT: [EventReservationWhereInput!]
  OR: [EventReservationWhereInput!]
  eventId: IntFilter
  eventType: StringFilter
  status: IntFilter
  user: UserRelationFilter
}

input EventReservationWhereUniqueInput {
  eventId_eventType_userId: EventReservationEventIdEventTypeUserIdCompoundUniqueInput
}

enum EventType {
  hotTalk
  panel
  talk
  workshop
}

type EventUserApplications {
  talk: Int!
  workshop: Int!
}

type FieldError {
  field: String!
  message: String!
}

type File {
  _count: FileCount
  createdAt: DateTimeISO!
  etag: String!
  mimeType: String!
  name: String!
  size: Int!
  uid: String!
  updatedAt: DateTimeISO!
  url: String!
}

type FileCount {
  forCompany: Int!
  forPressRelease: Int!
  forResume: Int!
}

enum FileOrderByRelevanceFieldEnum {
  etag
  mimeType
  minioKey
  name
  uid
}

input FileOrderByRelevanceInput {
  fields: [FileOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input FileOrderByWithRelationAndSearchRelevanceInput {
  _relevance: FileOrderByRelevanceInput
  etag: SortOrder
  mimeType: SortOrder
  name: SortOrder
  size: SortOrder
  uploader: UserOrderByWithRelationAndSearchRelevanceInput
}

input FileRelationFilter {
  is: FileWhereInput
  isNot: FileWhereInput
}

input FileWhereInput {
  AND: [FileWhereInput!]
  NOT: [FileWhereInput!]
  OR: [FileWhereInput!]
  etag: StringFilter
  mimeType: StringFilter
  name: StringFilter
  size: IntFilter
  uploader: UserRelationFilter
}

type GateGuardianLog {
  eventId: Int!
  eventType: String!
  forCalendarItem: CalendarItem
  forUser: User
  scannedAt: DateTimeISO!
  scannedBy: User
}

input GateGuardianLogListRelationFilter {
  every: GateGuardianLogWhereInput
  none: GateGuardianLogWhereInput
  some: GateGuardianLogWhereInput
}

input GateGuardianLogOrderByRelationAggregateInput {
  _count: SortOrder
}

input GateGuardianLogWhereInput {
  AND: [GateGuardianLogWhereInput!]
  NOT: [GateGuardianLogWhereInput!]
  OR: [GateGuardianLogWhereInput!]
  eventId: IntFilter
  eventType: StringFilter
}

type GateGuardianScanResponse {
  alreadyScanned: Boolean!
  error: String
  hasReservation: Boolean!
  user: User
}

type Image {
  _count: ImageCount
  createdAt: DateTimeISO!
  full: ImageVariation!
  fullUrl: String!
  name: String!
  thumb: ImageVariation!
  thumbUrl: String!
  uid: String!
  updatedAt: DateTimeISO!
}

type ImageCount {
  ApplicationPresenter: Int!
  Company: Int!
  News: Int!
  Partner: Int!
  Sponsor: Int!
}

input ImageRelationFilter {
  is: ImageWhereInput
  isNot: ImageWhereInput
}

type ImageVariation {
  _count: ImageVariationCount
  etag: String!
  mimeType: String!
}

type ImageVariationCount {
  forFull: Int!
  forOriginal: Int!
  forThumb: Int!
}

input ImageVariationRelationFilter {
  is: ImageVariationWhereInput
  isNot: ImageVariationWhereInput
}

input ImageVariationWhereInput {
  AND: [ImageVariationWhereInput!]
  NOT: [ImageVariationWhereInput!]
  OR: [ImageVariationWhereInput!]
  etag: StringFilter
  mimeType: StringFilter
}

input ImageWhereInput {
  AND: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  full: ImageVariationRelationFilter
  name: StringFilter
  original: ImageVariationRelationFilter
  thumb: ImageVariationRelationFilter
  uploader: UserRelationFilter
}

type Industry {
  _count: IndustryCount
  name: String!
}

type IndustryCount {
  company: Int!
}

enum IndustryOrderByRelevanceFieldEnum {
  name
}

input IndustryOrderByRelevanceInput {
  fields: [IndustryOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input IndustryOrderByWithRelationAndSearchRelevanceInput {
  _relevance: IndustryOrderByRelevanceInput
  name: SortOrder
}

enum IndustryScalarFieldEnum {
  id
  name
}

input IndustryWhereInput {
  AND: [IndustryWhereInput!]
  NOT: [IndustryWhereInput!]
  OR: [IndustryWhereInput!]
  name: StringFilter
}

input IndustryWhereUniqueInput {
  name: String
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type Mutation {
  addCompanyMember(email: String!): String
  approveCompanyApplications(companies: [ApproveCompanyApplicationsInput!]!, season: String!): [CompanyApplicationApproval!]!
  checkPasswordReset(token: String!): User
  createCompanyApplication(info: CompanyApplicationCreateInput!): CreateCompanyApplicationResponse
  createCompanyApplicationFor(company: String!, info: CompanyApplicationCreateInput!, season: String!): CreateCompanyApplicationResponse
  createIndustry(name: String!): Industry
  createNews(info: NewsCreateInput!): NewsCreateResponse
  createPartner(info: PartnerCreateInput!, season: String!): CreatePartnerResponse!
  createPressRelease(info: PressReleaseWithFilesCreateInput!): CreatePressReleaseResponse
  createSeason(info: SeasonCreateInput!): Season
  createSponsor(info: SponsorCreateInput!, season: String!): CreateSponsorResponse!
  createTalkCategory(name: String!, season: String!): ApplicationTalkCategory
  deleteCalendarItem(uid: String!): Boolean!
  deleteCompanyPanel(uid: String!): Boolean!
  deleteNews(uid: String!): Boolean
  deletePartner(partner: String!): Boolean!
  deleteResume: Boolean!
  deleteSeason(uid: String!): Season
  deleteSponsor(sponsor: String!): Boolean!
  editApprovedCompanyApplication(info: CompanyApplicationApprovedEditInput!): EditApprovedCompanyApplicationResponse
  editNews(info: NewsCreateInput!, uid: String!): NewsCreateResponse
  gateGuardianScan(eventType: String!, eventUid: String!, userUid: String!): GateGuardianScanResponse
  login(identifier: String!, password: String!): AuthResponse!
  logout: Boolean!
  register(info: UserRegisterInput!): AuthResponse!
  registerCompany(info: CreateCompanyInput!): CreateCompanyResponse
  removeCompanyMember(email: String!): String
  renameIndustry(newName: String!, oldName: String!): Industry
  renameTalkCategory(newName: String!, oldName: String!, season: String!): ApplicationTalkCategory
  requestPasswordReset(identifier: String!): String!
  requestPasswordResetFor(uid: String!): String!
  resumeEntryScan(userUid: String!): Resume
  resumeScan(userUid: String!): String
  resumeSetIsFavourite(isFavourite: Boolean!, uid: String!): Boolean!
  scanUserQr(userUid: String!): CompanyScanUserQrResponse
  scanUserQrRefine(refineData: CompanyScanUserQrRefineData!, userUid: String!): CompanyScanUserQrResponse
  swapPartnerOrder(orderA: Int!, orderB: Int!, season: String!): Boolean!
  swapSponsorOrder(orderA: Int!, orderB: Int!, season: String!): Boolean!
  updateCalendarItem(input: CalendarUpdateInput!): CalendarItem
  updateCompanyApplicationFeedback(input: CompanyApplicationFeedbackCreateInput!): CompanyApplicationFeedback
  updateCompanyInfo(info: CreateCompanyInput!): CreateCompanyResponse
  updateCompanyMembersFor(company: String!, members: [String!]!): CreateCompanyResponse
  updateCompanyPanel(input: CompanyPanelUpdateInput!): CompanyPanel
  updateEventReservation(input: EventReservationUpdateInput!): EventReservationResponse
  updatePassword(currentPassword: String!, newPassword: String!, newPasswordRepeat: String!): UpdatePasswordResponse
  updatePressRelease(info: PressReleaseWithFilesCreateInput!, uid: String!): CreatePressReleaseResponse
  updateProfile(info: UserCreateInput!): UpdateProfileResponse
  updateResume(info: ResumeCreateInput!): ResumeCreateResponse
  updateScannerStatusFor(isScanner: Boolean!, uid: String!): Boolean!
  updateSeason(info: SeasonUpdateInput!): Season
  updateTranslation(data: TranslationCreateInput!): Translation
  updateUser(info: UserUpdateInput!, uid: String!): UpdateProfileResponse
  usePasswordReset(info: PasswordResetUseInput!): PasswordResetUseResponse!
  validateVat(vat: String!): ValidateVatResponse!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeNullableFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableFilter
  notIn: [DateTimeISO!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

type News {
  author: User
  content: String!
  createdAt: DateTimeISO!
  date: DateTimeISO!
  description: String!
  lang: String!
  photo: Image
  slug: String!
  title: String!
  uid: String!
  updatedAt: DateTimeISO!
}

input NewsCreateInput {
  content: String!
  date: DateTimeISO!
  description: String!
  lang: String!
  photo: Upload
  title: String!
}

type NewsCreateResponse {
  entity: News
  errors: [FieldError!]
}

input NewsFilter {
  take: Int
}

type Partner {
  name: String!
  order: Int!
  photo: Image
  uid: String!
  url: String!
}

input PartnerCreateInput {
  name: String!
  photo: Upload!
  url: String!
}

input PartnerListRelationFilter {
  every: PartnerWhereInput
  none: PartnerWhereInput
  some: PartnerWhereInput
}

input PartnerOrderByRelationAggregateInput {
  _count: SortOrder
}

input PartnerWhereInput {
  AND: [PartnerWhereInput!]
  NOT: [PartnerWhereInput!]
  OR: [PartnerWhereInput!]
  forSeason: SeasonRelationFilter
  name: StringFilter
  order: IntFilter
  photo: ImageRelationFilter
  url: StringFilter
}

input PasswordResetUseInput {
  newPassword: String!
  newPasswordRepeat: String!
  token: String!
}

type PasswordResetUseResponse {
  entity: Boolean
  errors: [FieldError!]
}

input PresenterCreateInput {
  bioEn: String!
  bioHr: String!
  firstName: String!
  lastName: String!
  photo: Upload!
}

type PressRelease {
  createdAt: DateTimeISO!
  file: File
  forSeason: Season
  published: DateTimeISO!
  title: String!
  uid: String!
  updatedAt: DateTimeISO!
}

enum PressReleaseOrderByRelevanceFieldEnum {
  title
  uid
}

input PressReleaseOrderByRelevanceInput {
  fields: [PressReleaseOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input PressReleaseOrderByWithRelationAndSearchRelevanceInput {
  _relevance: PressReleaseOrderByRelevanceInput
  creator: UserOrderByWithRelationAndSearchRelevanceInput
  file: FileOrderByWithRelationAndSearchRelevanceInput
  forSeason: SeasonOrderByWithRelationAndSearchRelevanceInput
  published: SortOrder
  title: SortOrder
}

enum PressReleaseScalarFieldEnum {
  createdAt
  creatorId
  fileId
  forSeasonId
  id
  published
  title
  uid
  updatedAt
}

input PressReleaseWhereInput {
  AND: [PressReleaseWhereInput!]
  NOT: [PressReleaseWhereInput!]
  OR: [PressReleaseWhereInput!]
  creator: UserRelationFilter
  file: FileRelationFilter
  forSeason: SeasonRelationFilter
  published: DateTimeFilter
  title: StringFilter
}

input PressReleaseWhereUniqueInput {
  uid: String!
}

input PressReleaseWithFilesCreateInput {
  file: Upload
  published: DateTimeISO!
  season: String!
  title: String!
}

type Query {
  allNews(filter: NewsFilter): [News!]!
  allTranslationsFor(language: String!): [Translation!]!
  approvedCompanyApplications: [CompanyApplicationApproval!]!
  booths: [Booth!]!
  calendar(filter: CalendarFilterInput, season: String): [CalendarItem!]!
  calendarItem(uid: String!): CalendarItem
  calendarItemCompanyUid(uid: String!): String
  calendarOld: [CalendarEvent!]!
  companies(cursor: CompanyWhereUniqueInput, distinct: [CompanyScalarFieldEnum!], orderBy: [CompanyOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: CompanyWhereInput): [Company!]!
  company(vat: String!): Company
  companyApplication: CompanyApplication
  companyApplicationFor(company: String!, season: String!): CompanyApplication
  companyApplications(cursor: CompanyApplicationWhereUniqueInput, distinct: [CompanyApplicationScalarFieldEnum!], orderBy: [CompanyApplicationOrderByWithRelationAndSearchRelevanceInput!], season: String, skip: Int, take: Int, where: CompanyApplicationWhereInput): [CompanyApplication!]
  companyInfo(uid: String!): Company
  currentSeason: Season
  eventLog(orderBy: [EventLogOrderByWithRelationAndSearchRelevanceInput!], page: Int!, perPage: Int!, where: String): EventLogPaginationResult!
  findFirstTranslation(cursor: TranslationWhereUniqueInput, distinct: [TranslationScalarFieldEnum!], orderBy: [TranslationOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: TranslationWhereInput): Translation
  gateGuardianScanList(season: String!): [GateGuardianLog!]
  industries(cursor: IndustryWhereUniqueInput, distinct: [IndustryScalarFieldEnum!], orderBy: [IndustryOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: IndustryWhereInput): [Industry!]!
  news(filter: NewsFilter, lang: String!): [News!]!
  newsItem(slug: String!): News
  newsItemByUid(uid: String!): News
  participants(cursor: CompanyWhereUniqueInput, distinct: [CompanyScalarFieldEnum!], orderBy: [CompanyOrderByWithRelationAndSearchRelevanceInput!], season: String, skip: Int, take: Int, where: CompanyWhereInput): [Company!]!
  partners(season: String): [Partner!]!
  pressRelease(uid: String!): PressRelease
  pressReleases(cursor: PressReleaseWhereUniqueInput, distinct: [PressReleaseScalarFieldEnum!], orderBy: [PressReleaseOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: PressReleaseWhereInput): [PressRelease!]!
  profile: User
  resume(uid: String!): Resume
  resumeFavourites: [String!]!
  resumeInterests(index: Int, query: String!): SearchResponseStringArray!
  resumeIsFavourite(uid: String!): Boolean!
  resumeTechnologies(index: Int, query: String!): SearchResponseStringArray!
  resumes(filter: ResumeFindManyInput): ResumeList!
  resumesFavourites(filter: ResumeFindManyInput): ResumeList!
  resumesScanned(filter: ResumeFindManyInput): ResumeList!
  roles(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: RoleWhereInput): [Role!]!
  scannedUsers(companyUid: String, seasonUid: String): [CompanyScannedUser!]!
  season(uid: String!): Season
  seasons(cursor: SeasonWhereUniqueInput, distinct: [SeasonScalarFieldEnum!], orderBy: [SeasonOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: SeasonWhereInput): [Season!]!
  sessions: [Session!]!
  sessionsFor(uid: String!): [Session!]!
  sponsors(season: String): [Sponsor!]!
  talkCategories(cursor: ApplicationTalkCategoryWhereUniqueInput, distinct: [ApplicationTalkCategoryScalarFieldEnum!], orderBy: [ApplicationTalkCategoryOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ApplicationTalkCategoryWhereInput): [ApplicationTalkCategory!]!
  translation(where: TranslationWhereUniqueInput!): Translation
  translations(cursor: TranslationWhereUniqueInput, distinct: [TranslationScalarFieldEnum!], orderBy: [TranslationOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: TranslationWhereInput): [Translation!]!
  user(uid: String!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type ReservationItem {
  count: Float!
  type: String!
  uid: String!
}

type Resume {
  _count: ResumeCount
  city: String!
  createdAt: DateTimeISO!
  cv: File
  extraField: String!
  faculty: ResumeFaculty
  interests: [String!]!
  projects: [ResumeProject!]!
  studyYears: [ResumeStudyYear!]!
  technologies: [String!]!
  uid: String!
  updatedAt: DateTimeISO!
  user: User!
  volunteerExperiences: [ResumeVolunteerExperience!]!
  workExperiences: [ResumeWorkExperience!]!
}

type ResumeCount {
  entryLog: Int!
  favouriteResumes: Int!
  interests: Int!
  projects: Int!
  scannedResumes: Int!
  studyYears: Int!
  technologies: Int!
  volunteerExperiences: Int!
  workExperiences: Int!
}

input ResumeCreateCvInput {
  cv: Upload
  keepOld: Boolean!
}

input ResumeCreateInput {
  city: String!
  extraField: String
  faculty: ResumeFacultyCreateInput!
  interests: [String!]!
  pdf: ResumeCreateCvInput
  projects: [ResumeProjectCreateInput!]!
  studyYears: [ResumeStudyYearCreateInput!]!
  technologies: [String!]!
  volunteerExperiences: [ResumeVolunteerExperienceCreateInput!]!
  workExperiences: [ResumeWorkExperienceCreateInput!]!
}

type ResumeCreateResponse {
  entity: Resume
  errors: [FieldError!]
}

type ResumeFaculty {
  module: String!
  name: String!
  specialization: String!
}

input ResumeFacultyCreateInput {
  module: String!
  name: String!
}

enum ResumeFacultyOrderByRelevanceFieldEnum {
  module
  name
  specialization
}

input ResumeFacultyOrderByRelevanceInput {
  fields: [ResumeFacultyOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input ResumeFacultyOrderByWithRelationAndSearchRelevanceInput {
  _relevance: ResumeFacultyOrderByRelevanceInput
  module: SortOrder
  name: SortOrder
  specialization: SortOrder
}

input ResumeFacultyRelationFilter {
  is: ResumeFacultyWhereInput
  isNot: ResumeFacultyWhereInput
}

input ResumeFacultyWhereInput {
  AND: [ResumeFacultyWhereInput!]
  NOT: [ResumeFacultyWhereInput!]
  OR: [ResumeFacultyWhereInput!]
  module: StringFilter
  name: StringFilter
  specialization: StringFilter
}

input ResumeFindManyInput {
  orderBy: [ResumeOrderByWithRelationAndSearchRelevanceInput!]
  skip: Int
  take: Int
  where: ResumeWhereInput
  whereUser: String
}

input ResumeInterestListRelationFilter {
  every: ResumeInterestWhereInput
  none: ResumeInterestWhereInput
  some: ResumeInterestWhereInput
}

input ResumeInterestOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResumeInterestWhereInput {
  AND: [ResumeInterestWhereInput!]
  NOT: [ResumeInterestWhereInput!]
  OR: [ResumeInterestWhereInput!]
  name: StringFilter
}

type ResumeList {
  items: [Resume!]!
  total: Int!
}

enum ResumeOrderByRelevanceFieldEnum {
  city
  extraField
  uid
}

input ResumeOrderByRelevanceInput {
  fields: [ResumeOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input ResumeOrderByWithRelationAndSearchRelevanceInput {
  _relevance: ResumeOrderByRelevanceInput
  city: SortOrder
  extraField: SortOrder
  faculty: ResumeFacultyOrderByWithRelationAndSearchRelevanceInput
  interests: ResumeInterestOrderByRelationAggregateInput
  projects: ResumeProjectOrderByRelationAggregateInput
  studyYears: ResumeStudyYearOrderByRelationAggregateInput
  technologies: ResumeTechnologyOrderByRelationAggregateInput
  volunteerExperiences: ResumeVolunteerExperienceOrderByRelationAggregateInput
  workExperiences: ResumeWorkExperienceOrderByRelationAggregateInput
}

type ResumeProject {
  position: String!
  project: String!
  start: DateTimeISO!
  until: DateTimeISO
}

input ResumeProjectCreateInput {
  position: String!
  project: String!
  start: DateTimeISO!
  until: DateTimeISO
}

input ResumeProjectListRelationFilter {
  every: ResumeProjectWhereInput
  none: ResumeProjectWhereInput
  some: ResumeProjectWhereInput
}

input ResumeProjectOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResumeProjectWhereInput {
  AND: [ResumeProjectWhereInput!]
  NOT: [ResumeProjectWhereInput!]
  OR: [ResumeProjectWhereInput!]
  position: StringFilter
  project: StringFilter
  start: DateTimeFilter
  until: DateTimeNullableFilter
}

type ResumeStudyYear {
  studyType: String!
  studyYear: Int!
}

input ResumeStudyYearCreateInput {
  studyType: String!
  studyYear: Float!
}

input ResumeStudyYearListRelationFilter {
  every: ResumeStudyYearWhereInput
  none: ResumeStudyYearWhereInput
  some: ResumeStudyYearWhereInput
}

input ResumeStudyYearOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResumeStudyYearWhereInput {
  AND: [ResumeStudyYearWhereInput!]
  NOT: [ResumeStudyYearWhereInput!]
  OR: [ResumeStudyYearWhereInput!]
  studyType: StringFilter
  studyYear: IntFilter
}

input ResumeTechnologyListRelationFilter {
  every: ResumeTechnologyWhereInput
  none: ResumeTechnologyWhereInput
  some: ResumeTechnologyWhereInput
}

input ResumeTechnologyOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResumeTechnologyWhereInput {
  AND: [ResumeTechnologyWhereInput!]
  NOT: [ResumeTechnologyWhereInput!]
  OR: [ResumeTechnologyWhereInput!]
  name: StringFilter
}

type ResumeVolunteerExperience {
  organisation: String!
  position: String!
  start: DateTimeISO!
  until: DateTimeISO
}

input ResumeVolunteerExperienceCreateInput {
  organisation: String!
  position: String!
  start: DateTimeISO!
  until: DateTimeISO
}

input ResumeVolunteerExperienceListRelationFilter {
  every: ResumeVolunteerExperienceWhereInput
  none: ResumeVolunteerExperienceWhereInput
  some: ResumeVolunteerExperienceWhereInput
}

input ResumeVolunteerExperienceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResumeVolunteerExperienceWhereInput {
  AND: [ResumeVolunteerExperienceWhereInput!]
  NOT: [ResumeVolunteerExperienceWhereInput!]
  OR: [ResumeVolunteerExperienceWhereInput!]
  organisation: StringFilter
  position: StringFilter
  start: DateTimeFilter
  until: DateTimeNullableFilter
}

input ResumeWhereInput {
  AND: [ResumeWhereInput!]
  NOT: [ResumeWhereInput!]
  OR: [ResumeWhereInput!]
  city: StringFilter
  extraField: StringFilter
  faculty: ResumeFacultyRelationFilter
  interests: ResumeInterestListRelationFilter
  projects: ResumeProjectListRelationFilter
  studyYears: ResumeStudyYearListRelationFilter
  technologies: ResumeTechnologyListRelationFilter
  volunteerExperiences: ResumeVolunteerExperienceListRelationFilter
  workExperiences: ResumeWorkExperienceListRelationFilter
}

type ResumeWorkExperience {
  company: String!
  position: String!
  start: DateTimeISO!
  until: DateTimeISO
}

input ResumeWorkExperienceCreateInput {
  company: String!
  position: String!
  start: DateTimeISO!
  until: DateTimeISO
}

input ResumeWorkExperienceListRelationFilter {
  every: ResumeWorkExperienceWhereInput
  none: ResumeWorkExperienceWhereInput
  some: ResumeWorkExperienceWhereInput
}

input ResumeWorkExperienceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResumeWorkExperienceWhereInput {
  AND: [ResumeWorkExperienceWhereInput!]
  NOT: [ResumeWorkExperienceWhereInput!]
  OR: [ResumeWorkExperienceWhereInput!]
  company: StringFilter
  position: StringFilter
  start: DateTimeFilter
  until: DateTimeNullableFilter
}

type Role {
  _count: RoleCount
  createdAt: DateTimeISO!
  name: String!
  updatedAt: DateTimeISO!
}

type RoleCount {
  users: Int!
}

enum RoleOrderByRelevanceFieldEnum {
  name
}

input RoleOrderByRelevanceInput {
  fields: [RoleOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input RoleOrderByWithRelationAndSearchRelevanceInput {
  _relevance: RoleOrderByRelevanceInput
  name: SortOrder
}

enum RoleScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  name: StringFilter
}

input RoleWhereUniqueInput {
  name: String
}

type SearchResponseStringArray {
  entities: [String!]!
  index: Float!
}

type Season {
  _count: SeasonCount
  applications: [CompanyApplication!]!
  applicationsEditableFrom: DateTimeISO!
  applicationsEditableUntil: DateTimeISO!
  applicationsFrom: DateTimeISO!
  applicationsUntil: DateTimeISO!
  calendar: [CalendarItem!]!
  companyScannedCvs: Int!
  endsAt: DateTimeISO!
  entryCount: Int!
  eventFrom: DateTimeISO!
  eventUntil: DateTimeISO!
  feedbackFrom: DateTimeISO!
  feedbackUntil: DateTimeISO!
  name: String!
  panel: CompanyPanel
  reservations: [ReservationItem!]!
  scheduleFrom: DateTimeISO!
  scheduleUntil: DateTimeISO!
  showParticipantsFrom: DateTimeISO!
  showParticipantsUntil: DateTimeISO!
  showPartnersFrom: DateTimeISO!
  showPartnersUntil: DateTimeISO!
  showSponsorsFrom: DateTimeISO!
  showSponsorsUntil: DateTimeISO!
  startsAt: DateTimeISO!
  uid: String!
}

type SeasonCount {
  calendar: Int!
  companies: Int!
  entryLog: Int!
  favouriteResumes: Int!
  gateGuardianLog: Int!
  partners: Int!
  pressReleases: Int!
  scannedResumes: Int!
  scannedUsers: Int!
  sponsors: Int!
  talkCategories: Int!
}

input SeasonCreateInput {
  applicationsEditableFrom: DateTimeISO!
  applicationsEditableUntil: DateTimeISO!
  applicationsFrom: DateTimeISO!
  applicationsUntil: DateTimeISO!
  endsAt: DateTimeISO!
  eventFrom: DateTimeISO!
  eventUntil: DateTimeISO!
  feedbackFrom: DateTimeISO!
  feedbackUntil: DateTimeISO!
  name: String!
  scheduleFrom: DateTimeISO!
  scheduleUntil: DateTimeISO!
  showParticipantsFrom: DateTimeISO!
  showParticipantsUntil: DateTimeISO!
  showPartnersFrom: DateTimeISO!
  showPartnersUntil: DateTimeISO!
  showSponsorsFrom: DateTimeISO!
  showSponsorsUntil: DateTimeISO!
  startsAt: DateTimeISO!
}

enum SeasonOrderByRelevanceFieldEnum {
  name
  uid
}

input SeasonOrderByRelevanceInput {
  fields: [SeasonOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input SeasonOrderByWithRelationAndSearchRelevanceInput {
  _relevance: SeasonOrderByRelevanceInput
  applicationsEditableFrom: SortOrder
  applicationsEditableUntil: SortOrder
  applicationsFrom: SortOrder
  applicationsUntil: SortOrder
  calendar: CalendarItemOrderByRelationAggregateInput
  companies: CompanyApplicationOrderByRelationAggregateInput
  endsAt: SortOrder
  eventFrom: SortOrder
  eventUntil: SortOrder
  feedbackFrom: SortOrder
  feedbackUntil: SortOrder
  gateGuardianLog: GateGuardianLogOrderByRelationAggregateInput
  name: SortOrder
  partners: PartnerOrderByRelationAggregateInput
  scannedUsers: CompanyScannedUserOrderByRelationAggregateInput
  scheduleFrom: SortOrder
  scheduleUntil: SortOrder
  showParticipantsFrom: SortOrder
  showParticipantsUntil: SortOrder
  showPartnersFrom: SortOrder
  showPartnersUntil: SortOrder
  showSponsorsFrom: SortOrder
  showSponsorsUntil: SortOrder
  sponsors: SponsorOrderByRelationAggregateInput
  startsAt: SortOrder
  uid: SortOrder
}

input SeasonRelationFilter {
  is: SeasonWhereInput
  isNot: SeasonWhereInput
}

enum SeasonScalarFieldEnum {
  applicationsEditableFrom
  applicationsEditableUntil
  applicationsFrom
  applicationsUntil
  endsAt
  eventFrom
  eventUntil
  feedbackFrom
  feedbackUntil
  id
  name
  scheduleFrom
  scheduleUntil
  showParticipantsFrom
  showParticipantsUntil
  showPartnersFrom
  showPartnersUntil
  showSponsorsFrom
  showSponsorsUntil
  startsAt
  uid
}

input SeasonUpdateInput {
  applicationsEditableFrom: DateTimeISO!
  applicationsEditableUntil: DateTimeISO!
  applicationsFrom: DateTimeISO!
  applicationsUntil: DateTimeISO!
  endsAt: DateTimeISO!
  eventFrom: DateTimeISO!
  eventUntil: DateTimeISO!
  feedbackFrom: DateTimeISO!
  feedbackUntil: DateTimeISO!
  name: String!
  scheduleFrom: DateTimeISO!
  scheduleUntil: DateTimeISO!
  showParticipantsFrom: DateTimeISO!
  showParticipantsUntil: DateTimeISO!
  showPartnersFrom: DateTimeISO!
  showPartnersUntil: DateTimeISO!
  showSponsorsFrom: DateTimeISO!
  showSponsorsUntil: DateTimeISO!
  startsAt: DateTimeISO!
  uid: String!
}

input SeasonWhereInput {
  AND: [SeasonWhereInput!]
  NOT: [SeasonWhereInput!]
  OR: [SeasonWhereInput!]
  applicationsEditableFrom: DateTimeFilter
  applicationsEditableUntil: DateTimeFilter
  applicationsFrom: DateTimeFilter
  applicationsUntil: DateTimeFilter
  calendar: CalendarItemListRelationFilter
  companies: CompanyApplicationListRelationFilter
  endsAt: DateTimeFilter
  eventFrom: DateTimeFilter
  eventUntil: DateTimeFilter
  feedbackFrom: DateTimeFilter
  feedbackUntil: DateTimeFilter
  gateGuardianLog: GateGuardianLogListRelationFilter
  name: StringFilter
  partners: PartnerListRelationFilter
  scannedUsers: CompanyScannedUserListRelationFilter
  scheduleFrom: DateTimeFilter
  scheduleUntil: DateTimeFilter
  showParticipantsFrom: DateTimeFilter
  showParticipantsUntil: DateTimeFilter
  showPartnersFrom: DateTimeFilter
  showPartnersUntil: DateTimeFilter
  showSponsorsFrom: DateTimeFilter
  showSponsorsUntil: DateTimeFilter
  sponsors: SponsorListRelationFilter
  startsAt: DateTimeFilter
  uid: StringFilter
}

input SeasonWhereUniqueInput {
  uid: String
}

type Session {
  id: Int!
  ip: String!
  loggedInAt: String!
  sessionId: String!
  userAgent: String!
}

enum SortOrder {
  asc
  desc
}

type Sponsor {
  name: String!
  order: Int!
  photo: Image
  uid: String!
  url: String!
}

input SponsorCreateInput {
  name: String!
  photo: Upload!
  url: String!
}

input SponsorListRelationFilter {
  every: SponsorWhereInput
  none: SponsorWhereInput
  some: SponsorWhereInput
}

input SponsorOrderByRelationAggregateInput {
  _count: SortOrder
}

input SponsorWhereInput {
  AND: [SponsorWhereInput!]
  NOT: [SponsorWhereInput!]
  OR: [SponsorWhereInput!]
  forSeason: SeasonRelationFilter
  name: StringFilter
  order: IntFilter
  photo: ImageRelationFilter
  url: StringFilter
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input TalkCreateInput {
  category: String!
  descriptionEn: String!
  descriptionHr: String!
  language: String!
  presenter: PresenterCreateInput!
  titleEn: String!
  titleHr: String!
}

input TalksCreateInput {
  category: String!
  descriptionEn: String!
  descriptionHr: String!
  language: String!
  presenter: [PresenterCreateInput!]!
  titleEn: String!
  titleHr: String!
}

type Translation {
  createdAt: DateTimeISO!
  key: String!
  language: String!
  updatedAt: DateTimeISO!
  value: String!
}

input TranslationCreateInput {
  key: String!
  language: String!
  value: String!
}

input TranslationKeyLanguageCompoundUniqueInput {
  key: String!
  language: String!
}

enum TranslationOrderByRelevanceFieldEnum {
  key
  language
  value
}

input TranslationOrderByRelevanceInput {
  fields: [TranslationOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input TranslationOrderByWithRelationAndSearchRelevanceInput {
  _relevance: TranslationOrderByRelevanceInput
  key: SortOrder
  language: SortOrder
  value: SortOrder
}

enum TranslationScalarFieldEnum {
  createdAt
  key
  language
  updatedAt
  value
}

input TranslationWhereInput {
  AND: [TranslationWhereInput!]
  NOT: [TranslationWhereInput!]
  OR: [TranslationWhereInput!]
  key: StringFilter
  language: StringFilter
  value: StringFilter
}

input TranslationWhereUniqueInput {
  key_language: TranslationKeyLanguageCompoundUniqueInput
}

type UpdatePasswordResponse {
  entity: User
  errors: [FieldError!]
}

type UpdateProfileResponse {
  entity: User
  errors: [FieldError!]
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  _count: UserCount
  companies: [Company!]!
  createdAt: DateTimeISO!
  email: String!
  eventLog: [EventLog!]!
  firstName: String!
  language: String!
  lastName: String!
  name: String!
  phone: String!
  resume: Resume
  roles: [Role!]!
  uid: String!
  updatedAt: DateTimeISO!
}

type UserCount {
  News: Int!
  companies: Int!
  events: Int!
  files: Int!
  gateGuardianEntryLog: Int!
  gateGuardianScannedLog: Int!
  images: Int!
  passwordResets: Int!
  pressReleases: Int!
  reservations: Int!
  roles: Int!
  scannedEntries: Int!
  scannedUsers: Int!
}

input UserCreateInput {
  email: String!
  firstName: String!
  language: String
  lastName: String!
  password: String!
  phone: String!
  reservations: EventReservationCreateNestedManyWithoutUserInput
}

enum UserOrderByRelevanceFieldEnum {
  email
  firstName
  language
  lastName
  password
  phone
  uid
}

input UserOrderByRelevanceInput {
  fields: [UserOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input UserOrderByWithRelationAndSearchRelevanceInput {
  _relevance: UserOrderByRelevanceInput
  email: SortOrder
  firstName: SortOrder
  language: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  reservations: EventReservationOrderByRelationAggregateInput
}

input UserRegisterInput {
  email: String!
  firstName: String!
  language: String
  lastName: String!
  password: String!
  passwordRepeat: String!
  phone: String!
  reservations: EventReservationCreateNestedManyWithoutUserInput
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  firstName
  id
  language
  lastName
  password
  phone
  resumeId
  uid
  updatedAt
}

input UserUpdateInput {
  email: String!
  firstName: String!
  language: String
  lastName: String!
  password: String!
  phone: String!
  reservations: EventReservationCreateNestedManyWithoutUserInput
  roles: [String!]!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  email: StringFilter
  firstName: StringFilter
  language: StringFilter
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
  reservations: EventReservationListRelationFilter
}

input UserWhereUniqueInput {
  email: String
}

type ValidateVatResponse {
  exists: Boolean!
  info: VatData
  valid: Boolean!
}

type VatData {
  address: String!
  legalName: String!
}

input WorkshopCreateInput {
  descriptionEn: String!
  descriptionHr: String!
  goal: String!
  language: String!
  notesEn: String!
  notesHr: String!
  presenter: PresenterCreateInput!
  titleEn: String!
  titleHr: String!
}

input WorkshopsCreateInput {
  descriptionEn: String!
  descriptionHr: String!
  goal: String!
  language: String!
  notesEn: String!
  notesHr: String!
  presenter: [PresenterCreateInput!]!
  titleEn: String!
  titleHr: String!
}